(self.webpackChunksite=self.webpackChunksite||[]).push([[5131],{3905:function(e,n,t){"use strict";t.d(n,{Zo:function(){return l},kt:function(){return m}});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)t=s[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)t=s[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var u=a.createContext({}),p=function(e){var n=a.useContext(u),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},l=function(e){var n=p(e.components);return a.createElement(u.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},c=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,s=e.originalType,u=e.parentName,l=o(e,["components","mdxType","originalType","parentName"]),c=p(t),m=r,g=c["".concat(u,".").concat(m)]||c[m]||d[m]||s;return t?a.createElement(g,i(i({ref:n},l),{},{components:t})):a.createElement(g,i({ref:n},l))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var s=t.length,i=new Array(s);i[0]=c;var o={};for(var u in n)hasOwnProperty.call(n,u)&&(o[u]=n[u]);o.originalType=e,o.mdxType="string"==typeof e?e:r,i[1]=o;for(var p=2;p<s;p++)i[p]=t[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}c.displayName="MDXCreateElement"},6742:function(e,n,t){"use strict";t.d(n,{Z:function(){return m}});var a=t(9756),r=t(7294),s=t(3727),i=t(2263),o=t(3919),u=t(412),p=(0,r.createContext)({collectLink:function(){}}),l=t(4996),d=t(8780),c=["isNavLink","to","href","activeClassName","isActive","data-noBrokenLinkCheck","autoAddBaseUrl"];var m=function(e){var n,t,m=e.isNavLink,g=e.to,f=e.href,h=e.activeClassName,w=e.isActive,v=e["data-noBrokenLinkCheck"],b=e.autoAddBaseUrl,k=void 0===b||b,N=(0,a.Z)(e,c),_=(0,i.Z)().siteConfig,O=_.trailingSlash,T=_.baseUrl,y=(0,l.C)().withBaseUrl,E=(0,r.useContext)(p),A=g||f,R=(0,o.Z)(A),U=null==A?void 0:A.replace("pathname://",""),G=void 0!==U?(t=U,k&&function(e){return e.startsWith("/")}(t)?y(t):t):void 0;G&&R&&(G=(0,d.applyTrailingSlash)(G,{trailingSlash:O,baseUrl:T}));var M,S=(0,r.useRef)(!1),P=m?s.OL:s.rU,D=u.Z.canUseIntersectionObserver;(0,r.useEffect)((function(){return!D&&R&&null!=G&&window.docusaurus.prefetch(G),function(){D&&M&&M.disconnect()}}),[G,D,R]);var C=null!==(n=null==G?void 0:G.startsWith("#"))&&void 0!==n&&n,B=!G||!R||C;return G&&R&&!C&&!v&&E.collectLink(G),B?r.createElement("a",Object.assign({href:G},A&&!R&&{target:"_blank",rel:"noopener noreferrer"},N)):r.createElement(P,Object.assign({},N,{onMouseEnter:function(){S.current||null==G||(window.docusaurus.preload(G),S.current=!0)},innerRef:function(e){var n,t;D&&e&&R&&(n=e,t=function(){null!=G&&window.docusaurus.prefetch(G)},(M=new window.IntersectionObserver((function(e){e.forEach((function(e){n===e.target&&(e.isIntersecting||e.intersectionRatio>0)&&(M.unobserve(n),M.disconnect(),t())}))}))).observe(n))},to:G||""},m&&{isActive:w,activeClassName:h}))}},3919:function(e,n,t){"use strict";function a(e){return!0===/^(\w*:|\/\/)/.test(e)}function r(e){return void 0!==e&&!a(e)}t.d(n,{b:function(){return a},Z:function(){return r}})},4996:function(e,n,t){"use strict";t.d(n,{C:function(){return s},Z:function(){return i}});var a=t(2263),r=t(3919);function s(){var e=(0,a.Z)().siteConfig,n=(e=void 0===e?{}:e).baseUrl,t=void 0===n?"/":n,s=e.url;return{withBaseUrl:function(e,n){return function(e,n,t,a){var s=void 0===a?{}:a,i=s.forcePrependBaseUrl,o=void 0!==i&&i,u=s.absolute,p=void 0!==u&&u;if(!t)return t;if(t.startsWith("#"))return t;if((0,r.b)(t))return t;if(o)return n+t;var l=t.startsWith(n)?t:n+t.replace(/^\//,"");return p?e+l:l}(s,t,e,n)}}}function i(e,n){return void 0===n&&(n={}),(0,s().withBaseUrl)(e,n)}},9443:function(e,n,t){"use strict";var a=(0,t(7294).createContext)(void 0);n.Z=a},8802:function(e,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.default=function(e,n){var t=n.trailingSlash,a=n.baseUrl;if(e.startsWith("#"))return e;if(void 0===t)return e;var r,s=e.split(/[#?]/)[0],i="/"===s||s===a?s:(r=s,t?function(e){return e.endsWith("/")?e:e+"/"}(r):function(e){return e.endsWith("/")?e.slice(0,-1):e}(r));return e.replace(s,i)}},8780:function(e,n,t){"use strict";var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(n,"__esModule",{value:!0}),n.uniq=n.applyTrailingSlash=void 0;var r=t(8802);Object.defineProperty(n,"applyTrailingSlash",{enumerable:!0,get:function(){return a(r).default}});var s=t(9964);Object.defineProperty(n,"uniq",{enumerable:!0,get:function(){return a(s).default}})},9964:function(e,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.default=function(e){return Array.from(new Set(e))}},2375:function(e,n,t){"use strict";t.d(n,{T:function(){return c},Z:function(){return m}});var a=t(7294),r=t(6742),s=t(5977),i=t(6010),o=t(9443);var u=function(){var e=(0,a.useContext)(o.Z);if(null==e)throw new Error('"useUserPreferencesContext" is used outside of "Layout" component.');return e},p={assemblyscript:"AssemblyScript",c:"C / C++",c3:"C3",d:"D",go:"Go",grain:"Grain",nelua:"Nelua",nim:"Nim",odin:"Odin",penne:"Penne",porth:"Porth",roland:"Roland",rust:"Rust",wat:"WebAssembly Text",zig:"Zig"};function l(e){return"string"==typeof e&&Object.prototype.hasOwnProperty.call(p,e)}function d(e){return(null!=e?e:"").trim().toLowerCase()}function c(e){var n=e.children,t=e.hidden,r=e.className;return a.createElement("div",{hidden:t,className:r},n)}function m(e){var n=a.Children.toArray(e.children),t=n.map((function(e){return e.props.value})),o=function(){var e=u(),n=e.tabGroupChoices,t=e.setTabGroupChoices,r=(0,a.useState)("assemblyscript"),s=r[0],i=r[1],o=function(e){var n=l(e);n?(i(e),t("language",e)):n||console.warn('MultilanguageCode: invalid code-lang received: "'+e+'"')},p=(0,a.useRef)(o);(0,a.useEffect)((function(){p.current=o}));var c="undefined"!=typeof window?window.location.search:"",m=n.language;return(0,a.useLayoutEffect)((function(){var e=d(m);l(e)&&i(e)}),[m]),(0,a.useEffect)((function(){var e=d(new URLSearchParams(c).get("code-lang"));l(e)&&p.current(e)}),[c]),{activeLang:s,updateLang:o}}().activeLang,c=(0,s.k6)(),m=t.includes(o)?o:t.includes("assemblyscript")?"assemblyscript":t[0],g=a.createElement("div",{className:"dropdown dropdown--hoverable dropdown--right"},a.createElement("a",{className:"navbar__link"},p[m]," "),a.createElement("ul",{className:"dropdown__menu text--left"},Object.entries(p).filter((function(e){return t.includes(e[0])})).map((function(e){var n=e[0],t=e[1],s=c.location.pathname+"?code-lang="+n+(c.location.hash||"#no-scroll");return a.createElement("li",{key:n},a.createElement(r.Z,{to:s,replace:!0,className:(0,i.Z)("dropdown__link",n===m&&"dropdown__link--active")},t))}))));return a.createElement("div",null,a.createElement("div",{className:"multilang"},g),a.createElement("div",null,n.map((function(e){return(0,a.cloneElement)(e,{key:e.props.value,hidden:e.props.value!==m})}))))}},364:function(e,n,t){"use strict";t.d(n,{Z:function(){return i}});var a=t(7294),r=t(2375),s={"language-typescript":"assemblyscript","language-javascript":"assemblyscript","language-c":"c","language-c3":"c3","language-cpp":"c","language-d":"d","language-grain":"grain","language-lua":"nelua","language-nelua":"nelua","language-nim":"nim","language-roland":"roland","language-rust":"rust","language-go":"go","language-odin":"odin","language-penne":"penne","language-porth":"porth","language-wasm":"wat","language-zig":"zig"};function i(e){var n=a.Children.toArray(e.children).map((function(e,n){return a.createElement(r.T,{key:n,value:s[e.props.children.props.className]},e)}));return a.createElement(r.Z,null,n)}},9920:function(e,n,t){"use strict";t.r(n),t.d(n,{frontMatter:function(){return u},contentTitle:function(){return p},metadata:function(){return l},toc:function(){return d},default:function(){return m}});var a=t(2122),r=t(9756),s=(t(7294),t(3905)),i=t(364),o=["components"],u={},p="Handling User Input",l={unversionedId:"guides/user-input",id:"guides/user-input",isDocsHomePage:!1,title:"Handling User Input",description:"Gamepad",source:"@site/docs/guides/user-input.md",sourceDirName:"guides",slug:"/guides/user-input",permalink:"/docs/guides/user-input",editUrl:"https://github.com/aduros/wasm4/edit/main/site/docs/guides/user-input.md",version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Drawing Basics",permalink:"/docs/guides/basic-drawing"},next:{title:"Drawing Sprites",permalink:"/docs/guides/sprites"}},d=[{value:"Gamepad",id:"gamepad",children:[{value:"Checking if a button was pressed this frame",id:"checking-if-a-button-was-pressed-this-frame",children:[]}]},{value:"Mouse",id:"mouse",children:[]}],c={toc:d};function m(e){var n=e.components,t=(0,r.Z)(e,o);return(0,s.kt)("wrapper",(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"handling-user-input"},"Handling User Input"),(0,s.kt)("h2",{id:"gamepad"},"Gamepad"),(0,s.kt)("p",null,"The main input device is the gamepad, consisting of 4 directions and 2 action\nbuttons. On computers, players use the arrow keys and the X and Z keys. On\nmobile, a virtual gamepad overlay is displayed that players can tap."),(0,s.kt)("p",null,"The gamepad state is stored by WASM-4 as one byte in memory, with each button\nstored as a single bit. For example, the right directional button is stored in\nbit 5. We can mask the gamepad with the ",(0,s.kt)("inlineCode",{parentName:"p"},"BUTTON_RIGHT")," constant to check if the\nright button is pressed."),(0,s.kt)(i.Z,{mdxType:"MultiLanguageCode"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},'const gamepad = load<u8>(w4.GAMEPAD1);\n\nif (gamepad & w4.BUTTON_RIGHT) {\n    w4.trace("Right button is down!");\n}\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},'uint8_t gamepad = *GAMEPAD1;\n\nif (gamepad & BUTTON_RIGHT) {\n    trace("Right button is down!");\n}\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c3"},'char gamepad = *w4::GAMEPAD1;\n\nif (gamepad & w4::BUTTON_RIGHT) \n{\n    w4::trace("Right button is down!");\n}\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-d"},'ubyte gamepad = *w4.gamepad1;\n\nif (gamepad & w4.buttonRight) {\n    w4.trace("Right button is down!");\n}\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-go"},'var gamepad = *w4.GAMEPAD1\n\nif gamepad&w4.BUTTON_RIGHT != 0 {\n    w4.Trace("Right button is down!")\n}\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-lua"},'local gamepad = $GAMEPAD1\n\nif gamepad & BUTTON_RIGHT ~= 0 then\n    trace("Right button is down!")\nend\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-nim"},'var gamepad = GAMEPAD1[]\n\nif bool(gamepad and BUTTON_RIGHT):\n  trace("Right button is down!")\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-odin"},'if .RIGHT in w4.GAMEPAD1^ {\n    w4.trace("Right button is down!")\n}\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-penne"},'if GAMEPAD1 & BUTTON_RIGHT != 0\n{\n    trace("Right button is down!");\n}\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-porth"},'memory gamepad sizeof(u8) end\n$GAMEPAD1 @8 gamepad !8\n\n$gamepad @8 $BUTTON_RIGHT and cast(bool) if\n  "Right button is down!"c trace\nend\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-roland"},'if GAMEPADS~[0] & BUTTON_RIGHT != 0 {\n   trace("Right button is down!");\n}\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},'let gamepad = unsafe { *GAMEPAD1 };\n\nif gamepad & BUTTON_RIGHT != 0 {\n    trace("Right button is down!");\n}\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-wasm"},'(data (i32.const 0x2000) "Right button is down!\\00")\n\n(local $gamepad i32)\n(local.set $gamepad (i32.load8_u (global.get $GAMEPAD1)))\n\n(if (i32.and (local.get $gamepad) (global.get $BUTTON_RIGHT))\n  (then\n    (call $trace (i32.const 0x2000))\n  )\n)\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-zig"},'const gamepad = w4.GAMEPAD1.*;\n\nif (gamepad & w4.BUTTON_RIGHT != 0) {\n    w4.trace("Right button is down!");\n}\n'))),(0,s.kt)("table",null,(0,s.kt)("thead",{parentName:"table"},(0,s.kt)("tr",{parentName:"thead"},(0,s.kt)("th",{parentName:"tr",align:null},"Gamepad Bit"),(0,s.kt)("th",{parentName:"tr",align:null},"Button"))),(0,s.kt)("tbody",{parentName:"table"},(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"0"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("inlineCode",{parentName:"td"},"BUTTON_1")," (1)")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"1"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("inlineCode",{parentName:"td"},"BUTTON_2")," (2)")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"2"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("em",{parentName:"td"},"Unused"))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"3"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("em",{parentName:"td"},"Unused"))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"4"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("inlineCode",{parentName:"td"},"BUTTON_LEFT")," (16)")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"5"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("inlineCode",{parentName:"td"},"BUTTON_RIGHT")," (32)")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"6"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("inlineCode",{parentName:"td"},"BUTTON_UP")," (64)")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"7"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("inlineCode",{parentName:"td"},"BUTTON_DOWN")," (128)")))),(0,s.kt)("h3",{id:"checking-if-a-button-was-pressed-this-frame"},"Checking if a button was pressed this frame"),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"GAMEPAD1")," stores the current state of the gamepad. It's common to want to know\nif a button was just pressed this frame. Another way of putting it: if a\nbutton was ",(0,s.kt)("em",{parentName:"p"},"not")," down last frame but ",(0,s.kt)("em",{parentName:"p"},"is")," down this frame."),(0,s.kt)("p",null,"This can be handled by storing the previous gamepad state, and then ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_XOR"},"bitwise\nXORing")," (",(0,s.kt)("inlineCode",{parentName:"p"},"^"),")\nit with the current gamepad state. This leaves us with a byte with only the\nbuttons that were pressed this frame."),(0,s.kt)(i.Z,{mdxType:"MultiLanguageCode"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},'let previousGamepad: u8;\n\nexport function update () {\n    const gamepad = load<u8>(w4.GAMEPAD1);\n\n    // Only the buttons that were pressed down this frame\n    const pressedThisFrame = gamepad & (gamepad ^ previousGamepad);\n    previousGamepad = gamepad;\n\n    if (pressedThisFrame & w4.BUTTON_RIGHT) {\n        trace("Right button was just pressed!");\n    }\n}\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},'uint8_t previousGamepad;\n\nvoid update () {\n    uint8_t gamepad = *GAMEPAD1;\n\n    // Only the buttons that were pressed down this frame\n    uint8_t pressedThisFrame = gamepad & (gamepad ^ previousGamepad);\n    previousGamepad = gamepad;\n\n    if (pressedThisFrame & BUTTON_RIGHT) {\n        trace("Right button was just pressed!");\n    }\n}\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c3"},'char previous_gamepad;\n\nfn void update () \n{\n    char gamepad = *w4::GAMEPAD1;\n\n    // Only the buttons that were pressed down this frame\n    char pressed_this_frame = gamepad & (gamepad ^ previous_gamepad);\n    previous_gamepad = gamepad;\n\n    if (pressed_this_frame & w4::BUTTON_RIGHT) \n    {\n        w4::trace("Right button was just pressed!");\n    }\n}\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-d"},'ubyte previousGamepad;\n\nvoid update() {\n    ubyte gamepad = *w4.gamepad1;\n\n    // Only the buttons that were pressed down this frame\n    ubyte pressedThisFrame = gamepad & (gamepad ^ previousGamepad);\n    previousGamepad = gamepad;\n\n    if (pressedThisFrame & w4.buttonRight) {\n        w4.trace("Right button was just pressed!");\n    }\n}\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-go"},'var previousGamepad byte\n\n//go:export update\nfunc update () {\n    var gamepad = *w4.GAMEPAD1\n\n    // Only the buttons that were pressed down this frame\n    var pressedThisFrame = gamepad & (gamepad ^ previousGamepad)\n    previousGamepad = gamepad\n\n    if pressedThisFrame&w4.BUTTON_RIGHT != 0 {\n        w4.Trace("Right button was just pressed!")\n    }\n}\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-lua"},'local previous_gamepad: uint8\n\nlocal function update()\n    local gamepad = $GAMEPAD1\n\n    -- Only the buttons that were pressed down this frame\n    local pressed_this_frame = gamepad & (gamepad ~ previous_gamepad)\n    previous_gamepad = gamepad\n\n    if pressed_this_frame & BUTTON_RIGHT ~= 0 then\n        trace("Right button was just pressed!")\n    end\nend\n\n## setup_wasm4_callbacks(update)\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-nim"},'var previousGamepad: uint8\n\nproc update {.exportWasm.} =\n  var gamepad = GAMEPAD1[]\n\n  # Only the buttons that were pressed down this frame\n  var pressedThisFrame = gamepad and (gamepad xor previousGamepad);\n  previousGamepad = gamepad\n\n  if bool(pressedThisFrame and BUTTON_RIGHT):\n    trace("Right button was just pressed!")\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-odin"},'previous_gamepad : w4.Buttons\n\n@export\nupdate :: proc "c" () {\n    gamepad := w4.GAMEPAD1^\n\n    // Only the buttons that were pressed down this frame\n    pressed_this_frame := gamepad & (gamepad ~ previous_gamepad)\n    previous_gamepad = gamepad\n\n    if .RIGHT in pressed_this_frame {\n        w4.trace("Right button was just pressed!")\n    }\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-penne"},'const PREVIOUS_GAMEPAD: &u8 = 0xF700;\n\npub extern fn update()\n{\n    // Only the buttons that were pressed down this frame.\n    var pressed_this_frame = GAMEPAD & (GAMEPAD ^ PREVIOUS_GAMEPAD);\n    PREVIOUS_GAMEPAD = GAMEPAD;\n\n    if pressed_this_frame & BUTTON_RIGHT != 0\n    {\n        trace("Right button was just pressed!");\n    }\n}\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-porth"},'memory prev-state sizeof(u8) end\n\nexport update "update"\nproc update in\n  $GAMEPAD1 @8\n  let gamepad in\n    gamepad prev-state @8 xor gamepad and\n    gamepad prev-state !8\n    let pressed-this-frame in\n      pressed-this-frame $BUTTON_RIGHT and cast(bool) if\n        "Right button was just pressed!"c trace\n      end\n    end\n  end\nend\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-roland"},'proc update() {\n   let previous = PREVIOUS_GAMEPAD;\n   let gamepad = GAMEPADS~[0];\n   // Only the buttons that were pressed down this frame\n   let pressed_this_frame = gamepad & (gamepad ^ previous);\n   PREVIOUS_GAMEPAD = gamepad;\n\n   if pressed_this_frame & BUTTON_RIGHT != 0 {\n      trace("Right button was just pressed!");\n   }\n}\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},'static mut PREVIOUS_GAMEPAD: u8 = 0;\n\n#[no_mangle]\nfn update() {\n    let (pressed_this_frame, ..) = unsafe {\n        let previous = PREVIOUS_GAMEPAD;\n        let gamepad = *GAMEPAD1;\n        // Only the buttons that were pressed down this frame\n        let pressed_this_frame = gamepad & (gamepad ^ previous);\n        PREVIOUS_GAMEPAD = gamepad;\n\n        (pressed_this_frame, gamepad, previous)\n    };\n\n    if pressed_this_frame & BUTTON_RIGHT != 0 {\n        trace("Right button was just pressed!");\n    }\n}\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-wasm"},';; Store the previous gamepad state in a global variable rather than linear\n;; memory. It is defined as a mutable global with the initial value 0.\n(global $previous-gamepad (mut i32) (i32.const 0))\n\n(data (i32.const 0x2000) "Right button was just pressed!\\00")\n\n(func (export "update")\n  (local $gamepad i32)\n  (local $pressed-this-frame i32)\n\n  (local.set $gamepad (i32.load8_u (global.get $GAMEPAD1)))\n\n  ;; Only the buttons that were pressed down this frame\n  (local.set $pressed-this-frame\n    (i32.and\n      (local.get $gamepad)\n      (i32.xor\n        (local.get $gamepad)\n        (global.get $previous-gamepad))))\n\n  (global.set $previous-gamepad (local.get $gamepad))\n\n  (if (i32.and (local.get $pressed-this-frame) (global.get $BUTTON_RIGHT))\n    (then\n      (call $trace (i32.const 0x2000))\n    )\n  )\n)\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-zig"},'var previous_gamepad: u8 = 0;\n\nexport fn update() void {\n    const gamepad = w4.GAMEPAD1.*;\n\n    const pressed_this_frame = gamepad & (gamepad ^ previous_gamepad);\n    previous_gamepad = gamepad;\n\n    if (pressed_this_frame & w4.BUTTON_RIGHT != 0) {\n        w4.trace("Right button was just pressed!");\n    }\n}\n'))),(0,s.kt)("h2",{id:"mouse"},"Mouse"),(0,s.kt)("p",null,"Mouse (or touchscreen) input is supported and will work for positions even outside of the game window on supported platforms.\nSee the ",(0,s.kt)("a",{parentName:"p",href:"/docs/reference/memory"},"Memory Map")," reference for more details on ",(0,s.kt)("inlineCode",{parentName:"p"},"MOUSE_X"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"MOUSE_Y"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"MOUSE_BUTTONS"),"."),(0,s.kt)("p",null,"On the example below, we can make a rectangle follow the mouse position and expand when clicked:"),(0,s.kt)(i.Z,{mdxType:"MultiLanguageCode"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},"export function update (): void {\n    const mouse  = load<u8>(w4.MOUSE_BUTTONS);\n    const mouseX = load<i16>(w4.MOUSE_X);\n    const mouseY = load<i16>(w4.MOUSE_Y);\n\n    if (mouse & w4.MOUSE_LEFT) {\n        store<u16>(w4.DRAW_COLORS, 4);\n        w4.rect(mouseX - 8, mouseY - 8, 16, 16);\n    } else {\n        store<u16>(w4.DRAW_COLORS, 2);\n        w4.rect(mouseX - 4, mouseY - 4, 8, 8);\n    }\n}\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c3"},"fn void update() @wasm()\n{\n    if (*w4::MOUSE & *w4::MOUSE_LEFT != 0)\n    {\n        *w4::DRAW_COLORS = 4;\n        w4::rect(*w4::MOUSE_X - 8, *w4::MOUSE_Y - 8, 16, 16);\n    }\n    else\n    {\n        *w4::DRAW_COLORS = 2;\n        w4::rect(*w4::MOUSE_X - 4, *w4::MOUSE_Y - 4, 8, 8);\n    }\n}\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-penne"},"pub extern update()\n{\n    if MOUSE & MOUSE_LEFT != 0\n    {\n        DRAW_COLORS = 4;\n        rect(MOUSE_X as i32 - 8, MOUSE_Y as i32 - 8, 16, 16);\n    }\n    else\n    {\n        DRAW_COLORS = 2;\n        rect(MOUSE_X as i32 - 4, MOUSE_Y as i32 - 4, 8, 8);\n    }\n}\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},"#[no_mangle]\nfn update() {\n    let mouse = unsafe { *MOUSE_BUTTONS };\n    let mouse_x = unsafe { *MOUSE_X };\n    let mouse_y = unsafe { *MOUSE_Y };\n\n    if mouse & MOUSE_LEFT != 0 {\n        unsafe { *DRAW_COLORS = 4 }\n        rect(i32::from(mouse_x) - 8, i32::from(mouse_y) - 8, 16, 16);\n    } else {\n        unsafe { *DRAW_COLORS = 2 }\n        rect(i32::from(mouse_x) - 4, i32::from(mouse_y) - 4, 8, 8);\n    }\n}\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-zig"},"export fn update() void {\n    const mouse = w4.MOUSE_BUTTONS.*;\n    const mouseX = w4.MOUSE_X.*;\n    const mouseY = w4.MOUSE_Y.*;\n\n    if (mouse & w4.MOUSE_LEFT) {\n        w4.DRAW_COLORS.* = 4;\n        w4.rect(@as(i32, mouseX) - 8, @as(i32, mouseY) - 8, 16, 16);\n    } else {\n        w4.DRAW_COLORS.* = 2;\n        w4.rect(@as(i32, mouseX) - 4, @as(i32, mouseY) - 4, 8, 8);\n    }\n}\n"))))}m.isMDXComponent=!0},6010:function(e,n,t){"use strict";function a(e){var n,t,r="";if("string"==typeof e||"number"==typeof e)r+=e;else if("object"==typeof e)if(Array.isArray(e))for(n=0;n<e.length;n++)e[n]&&(t=a(e[n]))&&(r&&(r+=" "),r+=t);else for(n in e)e[n]&&(r&&(r+=" "),r+=n);return r}function r(){for(var e,n,t=0,r="";t<arguments.length;)(e=arguments[t++])&&(n=a(e))&&(r&&(r+=" "),r+=n);return r}t.d(n,{Z:function(){return r}})}}]);