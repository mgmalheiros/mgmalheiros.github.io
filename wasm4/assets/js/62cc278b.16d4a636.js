(self.webpackChunksite=self.webpackChunksite||[]).push([[2423],{3905:function(e,n,t){"use strict";t.d(n,{Zo:function(){return u},kt:function(){return d}});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),c=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=c(e.components);return a.createElement(s.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},f=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),f=c(t),d=r,m=f["".concat(s,".").concat(d)]||f[d]||p[d]||o;return t?a.createElement(m,i(i({ref:n},u),{},{components:t})):a.createElement(m,i({ref:n},u))}));function d(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=f;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var c=2;c<o;c++)i[c]=t[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}f.displayName="MDXCreateElement"},6742:function(e,n,t){"use strict";t.d(n,{Z:function(){return d}});var a=t(9756),r=t(7294),o=t(3727),i=t(2263),l=t(3919),s=t(412),c=(0,r.createContext)({collectLink:function(){}}),u=t(4996),p=t(8780),f=["isNavLink","to","href","activeClassName","isActive","data-noBrokenLinkCheck","autoAddBaseUrl"];var d=function(e){var n,t,d=e.isNavLink,m=e.to,h=e.href,g=e.activeClassName,b=e.isActive,x=e["data-noBrokenLinkCheck"],k=e.autoAddBaseUrl,E=void 0===k||k,R=(0,a.Z)(e,f),w=(0,i.Z)().siteConfig,y=w.trailingSlash,N=w.baseUrl,T=(0,u.C)().withBaseUrl,A=(0,r.useContext)(c),v=m||h,F=(0,l.Z)(v),O=null==v?void 0:v.replace("pathname://",""),C=void 0!==O?(t=O,E&&function(e){return e.startsWith("/")}(t)?T(t):t):void 0;C&&F&&(C=(0,p.applyTrailingSlash)(C,{trailingSlash:y,baseUrl:N}));var L,_=(0,r.useRef)(!1),P=d?o.OL:o.rU,U=s.Z.canUseIntersectionObserver;(0,r.useEffect)((function(){return!U&&F&&null!=C&&window.docusaurus.prefetch(C),function(){U&&L&&L.disconnect()}}),[C,U,F]);var W=null!==(n=null==C?void 0:C.startsWith("#"))&&void 0!==n&&n,D=!C||!F||W;return C&&F&&!W&&!x&&A.collectLink(C),D?r.createElement("a",Object.assign({href:C},v&&!F&&{target:"_blank",rel:"noopener noreferrer"},R)):r.createElement(P,Object.assign({},R,{onMouseEnter:function(){_.current||null==C||(window.docusaurus.preload(C),_.current=!0)},innerRef:function(e){var n,t;U&&e&&F&&(n=e,t=function(){null!=C&&window.docusaurus.prefetch(C)},(L=new window.IntersectionObserver((function(e){e.forEach((function(e){n===e.target&&(e.isIntersecting||e.intersectionRatio>0)&&(L.unobserve(n),L.disconnect(),t())}))}))).observe(n))},to:C||""},d&&{isActive:b,activeClassName:g}))}},3919:function(e,n,t){"use strict";function a(e){return!0===/^(\w*:|\/\/)/.test(e)}function r(e){return void 0!==e&&!a(e)}t.d(n,{b:function(){return a},Z:function(){return r}})},4996:function(e,n,t){"use strict";t.d(n,{C:function(){return o},Z:function(){return i}});var a=t(2263),r=t(3919);function o(){var e=(0,a.Z)().siteConfig,n=(e=void 0===e?{}:e).baseUrl,t=void 0===n?"/":n,o=e.url;return{withBaseUrl:function(e,n){return function(e,n,t,a){var o=void 0===a?{}:a,i=o.forcePrependBaseUrl,l=void 0!==i&&i,s=o.absolute,c=void 0!==s&&s;if(!t)return t;if(t.startsWith("#"))return t;if((0,r.b)(t))return t;if(l)return n+t;var u=t.startsWith(n)?t:n+t.replace(/^\//,"");return c?e+u:u}(o,t,e,n)}}}function i(e,n){return void 0===n&&(n={}),(0,o().withBaseUrl)(e,n)}},9443:function(e,n,t){"use strict";var a=(0,t(7294).createContext)(void 0);n.Z=a},8802:function(e,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.default=function(e,n){var t=n.trailingSlash,a=n.baseUrl;if(e.startsWith("#"))return e;if(void 0===t)return e;var r,o=e.split(/[#?]/)[0],i="/"===o||o===a?o:(r=o,t?function(e){return e.endsWith("/")?e:e+"/"}(r):function(e){return e.endsWith("/")?e.slice(0,-1):e}(r));return e.replace(o,i)}},8780:function(e,n,t){"use strict";var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(n,"__esModule",{value:!0}),n.uniq=n.applyTrailingSlash=void 0;var r=t(8802);Object.defineProperty(n,"applyTrailingSlash",{enumerable:!0,get:function(){return a(r).default}});var o=t(9964);Object.defineProperty(n,"uniq",{enumerable:!0,get:function(){return a(o).default}})},9964:function(e,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.default=function(e){return Array.from(new Set(e))}},2375:function(e,n,t){"use strict";t.d(n,{T:function(){return f},Z:function(){return d}});var a=t(7294),r=t(6742),o=t(5977),i=t(6010),l=t(9443);var s=function(){var e=(0,a.useContext)(l.Z);if(null==e)throw new Error('"useUserPreferencesContext" is used outside of "Layout" component.');return e},c={assemblyscript:"AssemblyScript",c:"C / C++",c3:"C3",d:"D",go:"Go",grain:"Grain",nelua:"Nelua",nim:"Nim",odin:"Odin",penne:"Penne",porth:"Porth",roland:"Roland",rust:"Rust",wat:"WebAssembly Text",zig:"Zig"};function u(e){return"string"==typeof e&&Object.prototype.hasOwnProperty.call(c,e)}function p(e){return(null!=e?e:"").trim().toLowerCase()}function f(e){var n=e.children,t=e.hidden,r=e.className;return a.createElement("div",{hidden:t,className:r},n)}function d(e){var n=a.Children.toArray(e.children),t=n.map((function(e){return e.props.value})),l=function(){var e=s(),n=e.tabGroupChoices,t=e.setTabGroupChoices,r=(0,a.useState)("assemblyscript"),o=r[0],i=r[1],l=function(e){var n=u(e);n?(i(e),t("language",e)):n||console.warn('MultilanguageCode: invalid code-lang received: "'+e+'"')},c=(0,a.useRef)(l);(0,a.useEffect)((function(){c.current=l}));var f="undefined"!=typeof window?window.location.search:"",d=n.language;return(0,a.useLayoutEffect)((function(){var e=p(d);u(e)&&i(e)}),[d]),(0,a.useEffect)((function(){var e=p(new URLSearchParams(f).get("code-lang"));u(e)&&c.current(e)}),[f]),{activeLang:o,updateLang:l}}().activeLang,f=(0,o.k6)(),d=t.includes(l)?l:t.includes("assemblyscript")?"assemblyscript":t[0],m=a.createElement("div",{className:"dropdown dropdown--hoverable dropdown--right"},a.createElement("a",{className:"navbar__link"},c[d]," "),a.createElement("ul",{className:"dropdown__menu text--left"},Object.entries(c).filter((function(e){return t.includes(e[0])})).map((function(e){var n=e[0],t=e[1],o=f.location.pathname+"?code-lang="+n+(f.location.hash||"#no-scroll");return a.createElement("li",{key:n},a.createElement(r.Z,{to:o,replace:!0,className:(0,i.Z)("dropdown__link",n===d&&"dropdown__link--active")},t))}))));return a.createElement("div",null,a.createElement("div",{className:"multilang"},m),a.createElement("div",null,n.map((function(e){return(0,a.cloneElement)(e,{key:e.props.value,hidden:e.props.value!==d})}))))}},364:function(e,n,t){"use strict";t.d(n,{Z:function(){return i}});var a=t(7294),r=t(2375),o={"language-typescript":"assemblyscript","language-javascript":"assemblyscript","language-c":"c","language-c3":"c3","language-cpp":"c","language-d":"d","language-grain":"grain","language-lua":"nelua","language-nelua":"nelua","language-nim":"nim","language-roland":"roland","language-rust":"rust","language-go":"go","language-odin":"odin","language-penne":"penne","language-porth":"porth","language-wasm":"wat","language-zig":"zig"};function i(e){var n=a.Children.toArray(e.children).map((function(e,n){return a.createElement(r.T,{key:n,value:o[e.props.children.props.className]},e)}));return a.createElement(r.Z,null,n)}},1027:function(e,n,t){"use strict";t.r(n),t.d(n,{frontMatter:function(){return s},contentTitle:function(){return c},metadata:function(){return u},toc:function(){return p},default:function(){return d}});var a=t(2122),r=t(9756),o=(t(7294),t(3905)),i=t(364),l=["components"],s={},c="Drawing Basics",u={unversionedId:"guides/basic-drawing",id:"guides/basic-drawing",isDocsHomePage:!1,title:"Drawing Basics",description:"The PALETTE Register",source:"@site/docs/guides/basic-drawing.md",sourceDirName:"guides",slug:"/guides/basic-drawing",permalink:"/docs/guides/basic-drawing",editUrl:"https://github.com/aduros/wasm4/edit/main/site/docs/guides/basic-drawing.md",version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Hello World",permalink:"/docs/getting-started/hello-world"},next:{title:"Handling User Input",permalink:"/docs/guides/user-input"}},p=[{value:"The <code>PALETTE</code> Register",id:"the-palette-register",children:[]},{value:"The <code>DRAW_COLORS</code> Register",id:"the-draw_colors-register",children:[]},{value:"Other Shapes",id:"other-shapes",children:[]},{value:"Direct Framebuffer Access",id:"direct-framebuffer-access",children:[]}],f={toc:p};function d(e){var n=e.components,t=(0,r.Z)(e,l);return(0,o.kt)("wrapper",(0,a.Z)({},f,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"drawing-basics"},"Drawing Basics"),(0,o.kt)("h2",{id:"the-palette-register"},"The ",(0,o.kt)("inlineCode",{parentName:"h2"},"PALETTE")," Register"),(0,o.kt)("p",null,"WASM-4 can only display 4 colors on screen at a time. This palette's RGB values are stored in the ",(0,o.kt)("inlineCode",{parentName:"p"},"PALETTE")," memory register, and can be modified."),(0,o.kt)("p",null,"For example, to change the palette to ",(0,o.kt)("a",{parentName:"p",href:"https://lospec.com/palette-list/ice-cream-gb"},"Ice Cream GB"),":"),(0,o.kt)(i.Z,{mdxType:"MultiLanguageCode"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"store<u32>(w4.PALETTE, 0xfff6d3, 0 * sizeof<u32>());\nstore<u32>(w4.PALETTE, 0xf9a875, 1 * sizeof<u32>());\nstore<u32>(w4.PALETTE, 0xeb6b6f, 2 * sizeof<u32>());\nstore<u32>(w4.PALETTE, 0x7c3f58, 3 * sizeof<u32>());\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"},"PALETTE[0] = 0xfff6d3;\nPALETTE[1] = 0xf9a875;\nPALETTE[2] = 0xeb6b6f;\nPALETTE[3] = 0x7c3f58;\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c3"},"w4::PALETTE[0] = 0xfff6d3;\nw4::PALETTE[1] = 0xf9a875;\nw4::PALETTE[2] = 0xeb6b6f;\nw4::PALETTE[3] = 0x7c3f58;\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-d"},"w4.palette[0] = 0xfff6d3;\nw4.palette[1] = 0xf9a875;\nw4.palette[2] = 0xeb6b6f;\nw4.palette[3] = 0x7c3f58;\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"w4.PALETTE[0] = 0xfff6d3\nw4.PALETTE[1] = 0xf9a875\nw4.PALETTE[2] = 0xeb6b6f\nw4.PALETTE[3] = 0x7c3f58\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},"PALETTE[0] = 0xfff6d3\nPALETTE[1] = 0xf9a875\nPALETTE[2] = 0xeb6b6f\nPALETTE[3] = 0x7c3f58\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-nim"},"PALETTE[0] = 0xfff6d3\nPALETTE[1] = 0xf9a875\nPALETTE[2] = 0xeb6b6f\nPALETTE[3] = 0x7c3f58\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-odin"},"w4.PALETTE[0] = 0xfff6d3\nw4.PALETTE[1] = 0xf9a875\nw4.PALETTE[2] = 0xeb6b6f\nw4.PALETTE[3] = 0x7c3f58\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-penne"},"PALETTE[0] = 0xfff6d3;\nPALETTE[1] = 0xf9a875;\nPALETTE[2] = 0xeb6b6f;\nPALETTE[3] = 0x7c3f58;\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-porth"},"0xfff6d3 $PALETTE0 !int\n0xf9a875 $PALETTE1 !int\n0xeb6b6f $PALETTE2 !int\n0x7c3f58 $PALETTE3 !int\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-roland"},"PALETTE~ = [\n   0xfff6d3,\n   0xf9a875,\n   0xeb6b6f,\n   0x7c3f58,\n];\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"unsafe {\n    *PALETTE = [\n        0xfff6d3,\n        0xf9a875,\n        0xeb6b6f,\n        0x7c3f58,\n    ];\n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-wasm"},"(i32.store (global.get $PALETTE0) (i32.const 0xfff6d3))\n(i32.store (global.get $PALETTE1) (i32.const 0xf9a875))\n(i32.store (global.get $PALETTE2) (i32.const 0xeb6b6f))\n(i32.store (global.get $PALETTE3) (i32.const 0x7c3f58))\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-zig"},"w4.PALETTE.* = .{\n    0xfff6d3,\n    0xf9a875,\n    0xeb6b6f,\n    0x7c3f58,\n};\n"))),(0,o.kt)("p",null,"The palette colors are considered to be numbered 1-4, even though they may be accessed with indices 0-3."),(0,o.kt)("p",null,"The default Gameboy-ish palette looks like this:"),(0,o.kt)("div",{className:"row row--no-gutters"},(0,o.kt)("div",{className:"col col--2",style:{padding:"1.5rem",background:"#e0f8cf",color:"#000"}},"Color 1"),(0,o.kt)("div",{className:"col col--2",style:{padding:"1.5rem",background:"#86c06c",color:"#000"}},"Color 2"),(0,o.kt)("div",{className:"col col--2",style:{padding:"1.5rem",background:"#306850",color:"#fff"}},"Color 3"),(0,o.kt)("div",{className:"col col--2",style:{padding:"1.5rem",background:"#071821",color:"#fff"}},"Color 4")),(0,o.kt)("p",null,"The first color in the palette register is used as the screen background color."),(0,o.kt)("h2",{id:"the-draw_colors-register"},"The ",(0,o.kt)("inlineCode",{parentName:"h2"},"DRAW_COLORS")," Register"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"DRAW_COLORS")," is a set of 4 indexes into ",(0,o.kt)("inlineCode",{parentName:"p"},"PALETTE"),". Drawing functions use these indexes to\ndecide which colors to use, and what to use them for."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"DRAW_COLORS")," is a 16 bit value that holds 4 indexes. Bits 0-3 (the least significant bits)\nhold the first draw color, bits 4-7 hold the second draw color, and so on."),(0,o.kt)("p",null,"Setting a draw color to ",(0,o.kt)("inlineCode",{parentName:"p"},"1")," means use ",(0,o.kt)("inlineCode",{parentName:"p"},"PALETTE")," color 1 for that draw color. The same applies\nwhen setting a draw color to ",(0,o.kt)("inlineCode",{parentName:"p"},"2"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"3"),", or ",(0,o.kt)("inlineCode",{parentName:"p"},"4"),"."),(0,o.kt)("p",null,"For example, ",(0,o.kt)("inlineCode",{parentName:"p"},"rect()")," uses the first draw color for the fill color, and the second draw color\nas the outline color. To draw a light-green (palette color 2) rectangle with a black (palette color 4) outline:"),(0,o.kt)(i.Z,{mdxType:"MultiLanguageCode"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"store<u16>(w4.DRAW_COLORS, 0x42);\nw4.rect(10, 10, 32, 32);\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"},"*DRAW_COLORS = 0x42;\nrect(10, 10, 32, 32);\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c3"},"*w4::DRAW_COLORS = 0x42;\nw4::rect(10, 10, 32, 32);\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-d"},"*w4.drawColors = 0x42;\nw4.rect(10, 10, 32, 32);\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"*w4.DRAW_COLORS = 0x42\nw4.Rect(10, 10, 32, 32)\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},"$DRAW_COLORS = 0x42\nrect(10, 10, 32, 32)\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-nim"},"DRAW_COLORS[] = 0x42\nrect(10, 10, 32, 32)\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-odin"},"w4.DRAW_COLORS^ = 0x42\nw4.rect(10, 10, 32, 32)\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-penne"},"DRAW_COLORS = 0x42;\nrect(10, 10, 32, 32);\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-porth"},"0x42 $DRAW_COLORS !16\n32 32 10 10 rect\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-roland"},"DRAW_COLORS~ = 0x42;\nrect(10, 10, 32, 32);\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"unsafe { *DRAW_COLORS = 0x42 }\nrect(10, 10, 32, 32);\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-wasm"},";; Set DRAW_COLORS to 0x42.\n(i32.store16 (global.get $DRAW_COLORS) (i32.const 0x42))\n\n;; Draw a rectangle at (10, 10) with size (32, 32).\n(call $rect (i32.const 10) (i32.const 10) (i32.const 32) (i32.const 32))\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-zig"},"w4.DRAW_COLORS.* = 0x42;\nw4.rect(10, 10, 32, 32);\n"))),(0,o.kt)("p",null,"However, setting a draw color to ",(0,o.kt)("inlineCode",{parentName:"p"},"0")," will make it transparent. For example, to\ndraw a black outlined rectangle with no fill, set ",(0,o.kt)("inlineCode",{parentName:"p"},"DRAW_COLORS")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"0x40"),"."),(0,o.kt)("h2",{id:"other-shapes"},"Other Shapes"),(0,o.kt)("p",null,"For info on other shape drawing functions like ",(0,o.kt)("inlineCode",{parentName:"p"},"line()")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"oval()"),", see the ",(0,o.kt)("a",{parentName:"p",href:"/docs/reference/functions"},"Functions")," reference."),(0,o.kt)("h2",{id:"direct-framebuffer-access"},"Direct Framebuffer Access"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"FRAMEBUFFER")," memory region contains the framebuffer, with each byte containing 4 pixels (2 bits\nper pixel). In the framebuffer, the palette colors 1-4 are represented numerically as 0-3."),(0,o.kt)("p",null,"For example, to clear the entire screen to palette color 4, we write 3 into each position:"),(0,o.kt)(i.Z,{mdxType:"MultiLanguageCode"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"memory.fill(w4.FRAMEBUFFER, 3 | (3 << 2) | (3 << 4) | (3 << 6), 160*160/4);\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"},"memset(FRAMEBUFFER, 3 | (3 << 2) | (3 << 4) | (3 << 6), 160*160/4);\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c3"},"mem::set(w4::FRAMEBUFFER, 3 | (3 << 2) | (3 << 4) | (3 << 6), 160*160/4);\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-d"},"// Requires WASI_SDK_PATH to be set!\nimport core.stdc.string;\nmemset(w4.framebuffer, 3 | (3 << 2) | (3 << 4) | (3 << 6), 160*160/4);\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"for i := range w4.FRAMEBUFFER {\n    w4.FRAMEBUFFER[i] = 3 | (3 << 2) | (3 << 4) | (3 << 6)\n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},'require "memory"\nmemory.set(FRAMEBUFFER, (3 | (3 << 2) | (3 << 4) | (3 << 6)), 160*160/4)\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-nim"},"for i in 0..<len(FRAMEBUFFER[]):\n  FRAMEBUFFER[i] = 3 or (3 shl 2) or (3 shl 4) or (3 shl 6)\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-odin"},"for _, i in w4.FRAMEBUFFER {\n    w4.FRAMEBUFFER[i] = 3 | (3 << 2) | (3 << 4) | (3 << 6)\n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-penne"},"{\n    var i = 0;\n    var value = 3 | (3 << 2) | (3 << 4) | (3 << 6);\n    {\n        if i == |FRAMEBUFFER|\n            goto end;\n        FRAMEBUFFER[i] = value;\n        i = i + 1;\n        loop;\n    }\n    end:\n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-porth"},"$FRAMEBUFFER\n0 while dup 6400 < do\n  over over ptr+ 0xff swap !8\n  1 +\nend drop drop\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-roland"},"for i in 0..FRAMEBUFFER~.length {\n   FRAMEBUFFER~[i] = 3 | (3 << 2) | (3 << 4) | (3 << 6);\n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"unsafe {\n    (&mut *FRAMEBUFFER).fill(3 | (3 << 2) | (3 << 4) | (3 << 6));\n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-wasm"},";; i = 0;\n(local $i i32)\n\n(loop $loop\n  ;; FRAMEBUFFER[i] = 0xff;\n  (i32.store8 offset=0xa0 (local.get $i) (i32.const 0xff))\n\n  ;; i = i + 1;\n  (local.set $i (i32.add (local.get $i) (i32.const 1)))\n\n  ;; loop while i < 160*160/4\n  (br_if $loop (i32.lt_u (local.get $i) (i32.const 6400)))\n)\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-zig"},"for (w4.FRAMEBUFFER) |*x| {\n    x.* = 3 | (3 << 2) | (3 << 4) | (3 << 6);\n}\n"))),(0,o.kt)("p",null,"Advanced users can implement their own drawing functions by carefully manipulating the framebuffer.\nFor example, to implement a ",(0,o.kt)("inlineCode",{parentName:"p"},"pixel()")," function that draws a single pixel:"),(0,o.kt)(i.Z,{mdxType:"MultiLanguageCode"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"function pixel (x: i32, y: i32): void {\n    // The byte index into the framebuffer that contains (x, y)\n    const idx = (y*160 + x) >> 2;\n\n    // Calculate the bits within the byte that corresponds to our position\n    const shift = u8((x & 0b11) << 1);\n    const mask = u8(0b11 << shift);\n\n    // Use the first DRAW_COLOR as the pixel color.\n    const palette_color = u8(load<u16>(w4.DRAW_COLORS) & 0b1111);\n    if (palette_color == 0) {\n        // Transparent\n        return;\n    }\n    const color = (palette_color - 1) & 0b11;\n\n    // Write to the framebuffer\n    store<u8>(w4.FRAMEBUFFER + idx, (color << shift) | (load<u8>(w4.FRAMEBUFFER + idx) & ~mask));\n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"},"void pixel (int x, int y) {\n    // The byte index into the framebuffer that contains (x, y)\n    int idx = (y*160 + x) >> 2;\n\n    // Calculate the bits within the byte that corresponds to our position\n    int shift = (x & 0b11) << 1;\n    int mask = 0b11 << shift;\n\n    // Use the first DRAW_COLOR as the pixel color\n    int palette_color = *DRAW_COLORS & 0b1111;\n    if (palette_color == 0) {\n        // Transparent\n        return;\n    }\n    int color = (palette_color - 1) & 0b11;\n\n    // Write to the framebuffer\n    FRAMEBUFFER[idx] = (color << shift) | (FRAMEBUFFER[idx] & ~mask);\n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c3"},"fn void pixel(int x, int y) \n{\n    // The byte index into the framebuffer that contains (x, y)\n    int idx = (y * 160 + x) >> 2;\n\n    // Calculate the bits within the byte that corresponds to our position\n    int shift = (x & 0b11) << 1;\n    int mask = 0b11 << shift;\n\n    // Use the first DRAW_COLOR as the pixel color\n    int palette_color = *w4::DRAW_COLORS & 0b1111;\n    if (palette_color == 0) \n    {\n        // Transparent\n        return;\n    }\n    int color = (palette_color - 1) & 0b11;\n\n    // Write to the framebuffer\n    w4::FRAMEBUFFER[idx] = (color << shift) | (w4::FRAMEBUFFER[idx] & ~mask);\n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-d"},"void pixel(int x, int y) {\n    // The byte index into the framebuffer that contains (x, y)\n    int idx = (y * w4.screenSize + x) >> 2;\n\n    // Calculate the bits within the byte that corresponds to our position\n    int shift = (x & 0b11) << 1;\n    int mask = 0b11 << shift;\n\n    // Use the first draw color as the pixel color\n    int palette_color = *w4.drawColors & 0b1111;\n    if (palette_color == 0) {\n        // Transparent\n        return;\n    }\n    int color = (palette_color - 1) & 0b11;\n\n    // Write to the framebuffer\n    w4.framebuffer[idx] =\n        cast(ubyte)((color << shift) | (w4.framebuffer[idx] & ~mask));\n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"func pixel (x int, y int) {\n    // The byte index into the framebuffer that contains (x, y)\n    var idx = (y*160 + x) >> 2\n\n    // Calculate the bits within the byte that corresponds to our position\n    var shift = uint8((x & 0b11) << 1)\n    var mask = uint8(0b11 << shift)\n\n    // Use the first DRAW_COLOR as the pixel color\n    var palette_color = uint8(*w4.DRAW_COLORS & 0b1111)\n    if palette_color == 0 {\n        // Transparent\n        return\n    }\n    var color = uint8((palette_color - 1) & 0b11)\n\n    // Write to the framebuffer\n    w4.FRAMEBUFFER[idx] = (color << shift) | (w4.FRAMEBUFFER[idx] &^ mask)\n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},"local function pixel(x: integer, y: integer)\n    -- The byte index into the framebuffer that contains (x, y)\n    local idx = (y*160 + x) >> 2\n\n    -- Calculate the bits within the byte that corresponds to our position\n    local shift = (x & 0b11) << 1\n    local mask = 0b11 << shift\n\n    -- Use the first DRAW_COLOR as the pixel color\n    local palette_color = $DRAW_COLORS & 0b1111\n    if (palette_color == 0) then\n        -- Transparent\n        return\n    end\n    \n    local color = (palette_color - 1) & 0b11;\n\n    -- Write to the framebuffer\n    FRAMEBUFFER[idx] = (color << shift) | (FRAMEBUFFER[idx] & ~mask)\nend\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-nim"},"proc pixel(x, y: int32) =\n  # The byte index into the framebuffer that contains (x, y)\n  let idx = (y * SCREEN_SIZE + x) shr 2\n\n  # Calculate the bits within the byte that corresponds to our position\n  let shift = (x and 0b11) shl 1\n  let mask = uint8(0b11 shl shift)\n\n  # Use the first DRAW_COLOR as the pixel color\n  let palette_color = uint8(DRAW_COLORS[] and 0b1111)\n  if (palette_color == 0) {\n      // Transparent\n      return;\n  }\n  let color = (palette_color - 1) & 0b11\n\n  # Write to the framebuffer\n  FRAMEBUFFER[idx] = uint8((color shl shift) or (FRAMEBUFFER[idx] and not mask))\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-odin"},'pixel :: proc "c" (x : int, y : int) {\n    // The byte index into the framebuffer that contains (x, y)\n    idx := (y*160 + x) >> 2\n\n    // Calculate the bits within the byte that corresponds to our position\n    shift := u8((x & 0b11) << 1)\n    mask := u8(0b11 << shift)\n\n    // Use the first DRAW_COLOR as the pixel color\n    palette_color := u8(w4.DRAW_COLORS^ & 0b1111)\n    if (palette_color == 0) {\n        // Transparent\n        return\n    }\n    color := (palette_color - 1) & 0b11;\n\n    // Write to the framebuffer\n    w4.FRAMEBUFFER[idx] = (color << shift) | (w4.FRAMEBUFFER[idx] &~ mask)\n}\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-penne"},"fn pixel(x: i32, y: i32)\n{\n    // The byte index into the framebuffer that contains (x, y).\n    var idx = ((y as u32 * SCREEN_SIZE + x as u32) >> 2) as usize;\n\n    // Calculate the bits within the byte that corresponds to our position.\n    var shift = (x as u8 & 0b11) << 1;\n    var mask = 0b11 << shift;\n\n    // Use the first DRAW_COLOR as the pixel color.\n    var palette_color = (DRAW_COLORS & 0b1111) as u8;\n    if palette_color == 0\n    {\n        // Transparent\n        goto end;\n    }\n    var color = (palette_color - 1) & 0b11;\n\n    // Write to the framebuffer.\n    FRAMEBUFFER[idx] = (color << shift) | (FRAMEBUFFER[idx] & !mask);\n\n    end:\n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-porth"},"// TODO\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-roland"},"proc pixel(x: i32, y: i32) {\n   // The byte index into the framebuffer that contains (x, y)\n   let idx = (y transmute usize * 160 + x transmute usize) >> 2;\n\n   // Calculate the bits within the byte that corresponds to our position\n   let shift = (x truncate u8 & 0b11) << 1;\n   let mask = 0b11 << shift;\n\n   let palette_color: u8 = (DRAW_COLORS~ & 0xf) truncate u8;\n   if (palette_color == 0) {\n      // Transparent\n      return;\n   }\n   let color = (palette_color - 1) & 0b11;\n\n   // Write to the framebuffer\n   FRAMEBUFFER~[idx] = (color << shift) | (FRAMEBUFFER~[idx] & !mask);\n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"fn pixel(x: i32, y: i32) {\n    // The byte index into the framebuffer that contains (x, y)\n    let idx = (y as usize * 160 + x as usize) >> 2;\n\n    // Calculate the bits within the byte that corresponds to our position\n    let shift = (x as u8 & 0b11) << 1;\n    let mask = 0b11 << shift;\n\n    unsafe {\n        let palette_color: u8 = (*DRAW_COLORS & 0xf) as u8;\n        if (palette_color == 0) {\n            // Transparent\n            return;\n        }\n        let color = (palette_color - 1) & 0b11;\n\n        let framebuffer = &mut *FRAMEBUFFER;\n\n        framebuffer[idx] = (color << shift) | (framebuffer[idx] & !mask);\n    }\n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-wasm"},"(func $pixel (param $x i32) (param $y i32)\n  (local $idx i32)\n  (local $shift i32)\n  (local $mask i32)\n  (local $color i32)\n\n  ;; The byte index into the framebuffer that contains (x, y)\n  ;;  idx = (y*160 + x) >> 2;\n  (local.set $idx\n    (i32.shr_u\n      (i32.add\n        (i32.mul\n          (local.get $y)\n          (i32.const 160))\n        (local.get $x))\n      (i32.const 2)))\n\n  ;; Calculate the bits within the byte that corresponds to our position\n  ;; shift = (x & 0b11) << 1;\n  (local.set $shift\n    (i32.mul\n      (i32.and\n        (local.get $x)\n        (i32.const 3))\n      (i32.const 2)))\n\n  ;; mask = 0b11 << shift;\n  (local.set $mask\n    (i32.shl\n      (i32.const 3)\n      (local.get $shift)))\n\n  ;; Use the first DRAW_COLOR as the pixel color\n  ;; color = *DRAW_COLORS & 0b1111;\n  (local.set $color\n    (i32.and\n      (i32.load16_u (global.get $DRAW_COLORS))\n      (i32.const 15)))\n  ;; return if $color is zero, then subtract 1 and mask.\n  (if (i32.eqz (local.get $color)) (then (return)))\n  (local.set $color (i32.and\n                      (i32.const 3)\n                      (i32.sub (local.get $color) (i32.const 1))))\n\n  ;; Write to the framebuffer:\n  ;; FRAMEBUFFER[idx] = (color << shift) | (FRAMEBUFFER[idx] & ~mask);\n  ;;\n  ;; Note that WebAssembly doesn't have a bitwise not instruction, so\n  ;; `~n` becomes `n ^ ~0` (where -1 is used for ~0 below).\n  (i32.store8 offset=0xa0\n    (local.get $idx)\n    (i32.or\n      (i32.shl\n        (local.get $color)\n        (local.get $shift))\n      (i32.and\n        (i32.load8_u offset=0xa0 (local.get $idx))\n        (i32.xor\n          (local.get $mask)\n          (i32.const -1)))))\n)\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-zig"},"fn pixel(x: i32, y: i32) void {\n    // The byte index into the framebuffer that contains (x, y)\n    const idx = (@intCast(usize, y) * 160 + @intCast(usize, x)) >> 2;\n\n    // Calculate the bits within the byte that corresponds to our position\n    const shift = @intCast(u3, (x & 0b11) * 2);\n    const mask = @as(u8, 0b11) << shift;\n\n    // Use the first DRAW_COLOR as the pixel color\n    const palette_color = @intCast(u8, w4.DRAW_COLORS.* & 0b1111);\n    if (palette_color == 0) {\n        // Transparent\n        return;\n    }\n    const color = (palette_color - 1) & 0b11;\n\n    // Write to the framebuffer\n    w4.FRAMEBUFFER[idx] = (color << shift) | (w4.FRAMEBUFFER[idx] & ~mask);\n}\n"))))}d.isMDXComponent=!0},6010:function(e,n,t){"use strict";function a(e){var n,t,r="";if("string"==typeof e||"number"==typeof e)r+=e;else if("object"==typeof e)if(Array.isArray(e))for(n=0;n<e.length;n++)e[n]&&(t=a(e[n]))&&(r&&(r+=" "),r+=t);else for(n in e)e[n]&&(r&&(r+=" "),r+=n);return r}function r(){for(var e,n,t=0,r="";t<arguments.length;)(e=arguments[t++])&&(n=a(e))&&(r&&(r+=" "),r+=n);return r}t.d(n,{Z:function(){return r}})}}]);