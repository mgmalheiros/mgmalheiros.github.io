(self.webpackChunksite=self.webpackChunksite||[]).push([[9473],{3905:function(e,n,t){"use strict";t.d(n,{Zo:function(){return c},kt:function(){return h}});var a=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var s=a.createContext({}),u=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},c=function(e){var n=u(e.components);return a.createElement(s.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=u(t),h=o,m=d["".concat(s,".").concat(h)]||d[h]||p[h]||i;return t?a.createElement(m,r(r({ref:n},c),{},{components:t})):a.createElement(m,r({ref:n},c))}));function h(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var i=t.length,r=new Array(i);r[0]=d;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,r[1]=l;for(var u=2;u<i;u++)r[u]=t[u];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},4323:function(e,n,t){"use strict";t.r(n),t.d(n,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return u},toc:function(){return c},default:function(){return d}});var a=t(2122),o=t(9756),i=(t(7294),t(3905)),r=["components"],l={},s="Implementing a driver",u={unversionedId:"tutorials/iwas/implementing-the-driver",id:"tutorials/iwas/implementing-the-driver",isDocsHomePage:!1,title:"Implementing a driver",description:"For this guide, we will use the 1KB binary file directly.",source:"@site/docs/tutorials/iwas/implementing-the-driver.md",sourceDirName:"tutorials/iwas",slug:"/tutorials/iwas/implementing-the-driver",permalink:"/docs/tutorials/iwas/implementing-the-driver",editUrl:"https://github.com/aduros/wasm4/edit/main/site/docs/tutorials/iwas/implementing-the-driver.md",version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"The IWAS file format",permalink:"/docs/tutorials/iwas/the-iwas-file-format"},next:{title:"Finishing the sequencer",permalink:"/docs/tutorials/iwas/finishing-the-sequencer"}},c=[{value:"Getting started",id:"getting-started",children:[]},{value:"Lookup tables and variables",id:"lookup-tables-and-variables",children:[]},{value:"Declaring the function",id:"declaring-the-function",children:[]},{value:"Offsets and notes",id:"offsets-and-notes",children:[]},{value:"Reading notes",id:"reading-notes",children:[]},{value:"Getting the instrument",id:"getting-the-instrument",children:[]},{value:"Music speed and length",id:"music-speed-and-length",children:[]}],p={toc:c};function d(e){var n=e.components,t=(0,o.Z)(e,r);return(0,i.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"implementing-a-driver"},"Implementing a driver"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"For this guide, we will use the 1KB binary file directly.")),(0,i.kt)("p",null,"To get a byte array, you can either use an exporter, a command line tool, or (a web tool)","[https://notisrac.github.io/FileToCArray/]","."),(0,i.kt)("h2",{id:"getting-started"},"Getting started"),(0,i.kt)("p",null,"Once we have our file converted into a byte array, we should have it added on our code:"),(0,i.kt)("h2",{id:"lookup-tables-and-variables"},"Lookup tables and variables"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"/** Music data. */\nconst data: usize = memory.data<u8>([\n    // 1024 bytes...\n]);\n")),(0,i.kt)("p",null,"IWAS uses lookup tables for notes and speed values, so we can start including those, too:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"/** Note lookup table. */\nconst IWAS_NOTE_LOOKUP: usize = memory.data<u16>([\n    16,   17,   18,   19,   20,   21,   23,   24,\n    25,   27,   29,   30,   32,   34,   36,   38,\n    41,   43,   46,   49,   51,   55,   58,   61,\n    65,   69,   73,   77,   82,   87,   92,   98,\n   103,  110,  116,  123,  130,  138,  146,  155,\n   164,  174,  185,  196,  207,  220,  233,  246,\n   261,  277,  293,  311,  329,  349,  369,  392,\n   415,  440,  466,  493,  523,  554,  587,  622,\n   659,  698,  739,  783,  830,  880,  932,  987,\n  1046, 1108, 1174, 1244, 1318, 1396, 1479, 1567,\n  1661, 1760, 1864, 1975, 2093, 2217, 2349, 2489,\n  2637, 2793, 2959, 3135, 3322, 3520, 3729, 3951\n]);\n\n/** Speed lookup table. */\nconst IWAS_SPEED_LOOKUP: usize = memory.data<u8>([\n    0, 2, 4, 6, 8, 10, 20, 30, 40, 60, 80\n]);\n")),(0,i.kt)("p",null,"We will also require at least 2 variables to control the music:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"A speed counter")," to handle the speed."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"A cursor")," which will point to the next note that should be played.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"/** Speed counter. */\nlet counter: u8 = 0;\n\n/** Note cursor. */\nlet cursor: u8 = 0;\n")),(0,i.kt)("p",null,"And we also know that IWAS stores ",(0,i.kt)("inlineCode",{parentName:"p"},"u16")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"u32")," values as big-endian.\nWe won't be using the header for anything in this guide, so converting ",(0,i.kt)("inlineCode",{parentName:"p"},"u32"),"\nto the right order can be ignored."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"frq2")," property used by the instruments, however, is important, so we're adding\none small function to correct it to the right order later on:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"/**\n * Load `u16` value (big-endian).\n * \n * @param offset Address offset\n */\nfunction loadUint16BE(offset: usize): u16 {\n    /** High byte. */\n    const hi: u16 = u16(load<u8>(offset));\n\n    /** Low byte. */\n    const lo: u16 = u16(load<u8>(offset + 1));\n\n    return (hi * 0x100) + lo;\n}\n")),(0,i.kt)("h2",{id:"declaring-the-function"},"Declaring the function"),(0,i.kt)("p",null,"Let's make a ",(0,i.kt)("inlineCode",{parentName:"p"},"play")," function, which will be responsible for playing our music."),(0,i.kt)("p",null,"We can also figure what we need at the moment:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Make the countdown timer."),(0,i.kt)("li",{parentName:"ul"},"Check if it's ",(0,i.kt)("inlineCode",{parentName:"li"},"0"),"."),(0,i.kt)("li",{parentName:"ul"},"When it's ready to play a note, it will apply for all channels.")),(0,i.kt)("p",null,"And this is what we have:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"/**\n * Play music.\n */\nfunction play(): void {    \n    // Countdown delay...\n    counter = counter > 0? counter - 1: 0;\n    \n    // Return if it's not ready to play yet...\n    if(counter > 0) {\n        return;\n    }\n\n    // When it reaches zero, it will iterate through each channel to play \n    // every note...\n    for(let ichannel: u8 = 0; ichannel < 4; ichannel += 1) {\n        // ...\n    }\n}\n")),(0,i.kt)("h2",{id:"offsets-and-notes"},"Offsets and notes"),(0,i.kt)("p",null,"Next, we'll need to figure out a few things:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The offset for each channel."),(0,i.kt)("li",{parentName:"ul"},"The note value.")),(0,i.kt)("p",null,"The header is 32 bytes, and each channel has 224 bytes, which means we can get their offsets on a loop simply using ",(0,i.kt)("inlineCode",{parentName:"p"},"32 + (224 * ichannel)"),". The same thing applies with the note offset, except it will also add to the 32 bytes of the channel header."),(0,i.kt)("p",null,"We can also cap the cursor at 192, the maximum amount of notes a channel can have, in order to avoid any out-of-bounds shenanigans."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"/** Channel data offset. */\nconst offset: usize = data + 32 + (224 * ichannel);\n\n/** Note value. */\nconst note: i8 = load<i8>(offset + 32 + (cursor % 192));\n")),(0,i.kt)("p",null,"For the sake of consistency, we could also check if the ",(0,i.kt)("inlineCode",{parentName:"p"},"is_enabled")," property is set:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"/** Check if channel is enabled. */\nconst isEnabled: bool = load<bool>(offset + 30);\n\n// Ignore if is not enabled...\nif(!isEnabled) {\n    return;\n}\n")),(0,i.kt)("h2",{id:"reading-notes"},"Reading notes"),(0,i.kt)("p",null,"With an offset value and the note value, we can start to implement how each note should be interpreted."),(0,i.kt)("p",null,"The ",(0,i.kt)("strong",{parentName:"p"},"note break")," is a very specific value, so we can check for that first. It will interrupt any sounds\nbeing played on a given channel. To do that, we can simply reset the channel with an empty ",(0,i.kt)("inlineCode",{parentName:"p"},"tone"),"."),(0,i.kt)("p",null,"Apart from that, any valid note must be within ",(0,i.kt)("inlineCode",{parentName:"p"},"-96")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"96"),", and it can't be ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"// Notes with a value of -128 represent a note break.\n//\n// Note breaks will mute a specific channel if it's still\n// playing a tone.\nif(note === -128) {\n    w4.tone(0, 0, 0, ichannel);\n    continue;\n}\n// Notes ranging from -96 and 96 are valid tones.\n//\n// Positive notes will use the main channel, while\n// negative notes will use the shadow channel. \n//\n// Anything else, or 0, can be ignored.\nelse if(note !== 0 && note >= -96 && note <= 96) {\n    // ...\n}\n")),(0,i.kt)("h2",{id:"getting-the-instrument"},"Getting the instrument"),(0,i.kt)("p",null,'Each channel has 2 instruments available for use. For simplicity, IWAS calls each one a "main channel" and a "shadow channel".'),(0,i.kt)("p",null,"To check if a note should use the main or the shadow channel, we can look if the value is either positive or negative:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Positive values")," will use the ",(0,i.kt)("strong",{parentName:"li"},"main channel.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Negative values")," will use the ",(0,i.kt)("strong",{parentName:"li"},"shadow channel."))),(0,i.kt)("p",null,"Both instruments will have the same byte length, which is 9 bytes, and if we look at the data structure, we can see\nthey're pretty close from one to another."),(0,i.kt)("p",null,"We can calculate the offset of the instrument we need to fetch simply comparing if the value is positive, and if it is,\nthen we just need to add 9 to the result. That way we can point to the main channel or the shadow channel."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"/** Instrument offset (main channel if positive, shadow channel if negative). */\nconst instrument: usize = offset + (note > 0? 0: 9);\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"tone")," function uses 2 frequencies, but instruments only have ",(0,i.kt)("inlineCode",{parentName:"p"},"frq2"),". The ",(0,i.kt)("inlineCode",{parentName:"p"},"frq1")," is taken from the ",(0,i.kt)("strong",{parentName:"p"},"note lookup table"),",\nand we can calculate an offset for it, too:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"/** Note index for the note lookup table. If negative, it's value will be mirrored (e.g. `-1` becomes `1`). */\nconst inote: u8 = u8(Math.abs(note)) - 1;\n\n// Get frequency from note lookup table...\nconst frq1: u16 = load<u16>(IWAS_NOTE_LOOKUP + (inote * 2));\n")),(0,i.kt)("p",null,"Now we just need to fetch the instrument data and call ",(0,i.kt)("inlineCode",{parentName:"p"},"tone"),", mixing all the properties together with bitwise operations. We can also see\nour little-endian to big-endian function being used by ",(0,i.kt)("inlineCode",{parentName:"p"},"frq2"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"// Get instrument data.\n//\n// A positive note index should point to the main channel, and\n// a negative note index should point to the shadow channel.\n//\n// `frq2` is a big-endian value, so it must be converted.\n//\n// Values are converted to `u32` in order to better fit into the\n// bitwise operations needed for the `tone` function to work.\nconst frq2: u32 = u32(loadUint16BE(instrument));\nconst atk: u32= u32(load<u8>(instrument + 2));\nconst dec: u32 = u32(load<u8>(instrument + 3));\nconst sus: u32 = u32(load<u8>(instrument + 4));\nconst rel: u32 = u32(load<u8>(instrument + 5));\nconst peak: u32 = u32(load<u8>(instrument + 6));\nconst vol: u32 = u32(load<u8>(instrument + 7));\nconst mode: u32 = u32(load<u8>(instrument + 8));\nconst pan: u32 = 0;\n\n// Play tone:\nw4.tone(\n    frq1 | (frq2 << 16),\n    (atk << 24) | (dec << 16) | sus | (rel << 8),\n    (peak << 8) | vol,\n    ichannel | (mode << 2) | (pan << 4)\n);\n")),(0,i.kt)("p",null,"Also, notice how we're casting all values to ",(0,i.kt)("inlineCode",{parentName:"p"},"u32"),", despite being a single byte."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"tone")," function expects all arguments to be ",(0,i.kt)("inlineCode",{parentName:"p"},"u32"),", with all ADSR envelope settings\nbeing grouped together using bitwise operations. However, if we apply those on the values\nas ",(0,i.kt)("inlineCode",{parentName:"p"},"u8"),", they will occasionally wrap from 0 to 255 and thus potentially not giving the\nintended value."),(0,i.kt)("p",null,"This effect can be specially seen on ",(0,i.kt)("inlineCode",{parentName:"p"},"frq2"),", but it might affect other values, too, so we\nconvert all the values, just to be safe."),(0,i.kt)("h2",{id:"music-speed-and-length"},"Music speed and length"),(0,i.kt)("p",null,"Due to screen size limitations, IWAS splits a song into 12 pages, each one containing 16 notes.\nGetting the note count should be as simple as multiplying the page number by 16."),(0,i.kt)("p",null,"To reset the counter, we use the values provided by the speed lookup table."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"/** Music length. To get the actual note count, the page number can be multiplied by 16. */\nconst length: u8 = load<u8>(data + 6) * 16;\n\n/** Speed index for the speed lookup table. */\nconst ispeed: u8 = load<u8>(data + 7);\n\n/** Speed value. */\nconst speed: u8 = load<u8>(IWAS_SPEED_LOOKUP + ispeed);\n\n// Advance counter and cursor...\ncounter = speed;\ncursor = cursor < length? cursor + 1: 0;\n")))}d.isMDXComponent=!0}}]);