(self.webpackChunksite=self.webpackChunksite||[]).push([[3232],{3905:function(e,n,t){"use strict";t.d(n,{Zo:function(){return p},kt:function(){return A}});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)t=s[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)t=s[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),u=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=u(e.components);return a.createElement(l.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},c=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,s=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),c=u(t),A=r,m=c["".concat(l,".").concat(A)]||c[A]||d[A]||s;return t?a.createElement(m,o(o({ref:n},p),{},{components:t})):a.createElement(m,o({ref:n},p))}));function A(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var s=t.length,o=new Array(s);o[0]=c;var i={};for(var l in n)hasOwnProperty.call(n,l)&&(i[l]=n[l]);i.originalType=e,i.mdxType="string"==typeof e?e:r,o[1]=i;for(var u=2;u<s;u++)o[u]=t[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}c.displayName="MDXCreateElement"},6742:function(e,n,t){"use strict";t.d(n,{Z:function(){return A}});var a=t(9756),r=t(7294),s=t(3727),o=t(2263),i=t(3919),l=t(412),u=(0,r.createContext)({collectLink:function(){}}),p=t(4996),d=t(8780),c=["isNavLink","to","href","activeClassName","isActive","data-noBrokenLinkCheck","autoAddBaseUrl"];var A=function(e){var n,t,A=e.isNavLink,m=e.to,k=e.href,g=e.activeClassName,h=e.isActive,f=e["data-noBrokenLinkCheck"],w=e.autoAddBaseUrl,N=void 0===w||w,y=(0,a.Z)(e,c),T=(0,o.Z)().siteConfig,v=T.trailingSlash,b=T.baseUrl,D=(0,p.C)().withBaseUrl,P=(0,r.useContext)(u),O=m||k,_=(0,i.Z)(O),U=null==O?void 0:O.replace("pathname://",""),B=void 0!==U?(t=U,N&&function(e){return e.startsWith("/")}(t)?D(t):t):void 0;B&&_&&(B=(0,d.applyTrailingSlash)(B,{trailingSlash:v,baseUrl:b}));var j,E=(0,r.useRef)(!1),C=A?s.OL:s.rU,S=l.Z.canUseIntersectionObserver;(0,r.useEffect)((function(){return!S&&_&&null!=B&&window.docusaurus.prefetch(B),function(){S&&j&&j.disconnect()}}),[B,S,_]);var x=null!==(n=null==B?void 0:B.startsWith("#"))&&void 0!==n&&n,M=!B||!_||x;return B&&_&&!x&&!f&&P.collectLink(B),M?r.createElement("a",Object.assign({href:B},O&&!_&&{target:"_blank",rel:"noopener noreferrer"},y)):r.createElement(C,Object.assign({},y,{onMouseEnter:function(){E.current||null==B||(window.docusaurus.preload(B),E.current=!0)},innerRef:function(e){var n,t;S&&e&&_&&(n=e,t=function(){null!=B&&window.docusaurus.prefetch(B)},(j=new window.IntersectionObserver((function(e){e.forEach((function(e){n===e.target&&(e.isIntersecting||e.intersectionRatio>0)&&(j.unobserve(n),j.disconnect(),t())}))}))).observe(n))},to:B||""},A&&{isActive:h,activeClassName:g}))}},3919:function(e,n,t){"use strict";function a(e){return!0===/^(\w*:|\/\/)/.test(e)}function r(e){return void 0!==e&&!a(e)}t.d(n,{b:function(){return a},Z:function(){return r}})},4996:function(e,n,t){"use strict";t.d(n,{C:function(){return s},Z:function(){return o}});var a=t(2263),r=t(3919);function s(){var e=(0,a.Z)().siteConfig,n=(e=void 0===e?{}:e).baseUrl,t=void 0===n?"/":n,s=e.url;return{withBaseUrl:function(e,n){return function(e,n,t,a){var s=void 0===a?{}:a,o=s.forcePrependBaseUrl,i=void 0!==o&&o,l=s.absolute,u=void 0!==l&&l;if(!t)return t;if(t.startsWith("#"))return t;if((0,r.b)(t))return t;if(i)return n+t;var p=t.startsWith(n)?t:n+t.replace(/^\//,"");return u?e+p:p}(s,t,e,n)}}}function o(e,n){return void 0===n&&(n={}),(0,s().withBaseUrl)(e,n)}},9443:function(e,n,t){"use strict";var a=(0,t(7294).createContext)(void 0);n.Z=a},8802:function(e,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.default=function(e,n){var t=n.trailingSlash,a=n.baseUrl;if(e.startsWith("#"))return e;if(void 0===t)return e;var r,s=e.split(/[#?]/)[0],o="/"===s||s===a?s:(r=s,t?function(e){return e.endsWith("/")?e:e+"/"}(r):function(e){return e.endsWith("/")?e.slice(0,-1):e}(r));return e.replace(s,o)}},8780:function(e,n,t){"use strict";var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(n,"__esModule",{value:!0}),n.uniq=n.applyTrailingSlash=void 0;var r=t(8802);Object.defineProperty(n,"applyTrailingSlash",{enumerable:!0,get:function(){return a(r).default}});var s=t(9964);Object.defineProperty(n,"uniq",{enumerable:!0,get:function(){return a(s).default}})},9964:function(e,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.default=function(e){return Array.from(new Set(e))}},2375:function(e,n,t){"use strict";t.d(n,{T:function(){return c},Z:function(){return A}});var a=t(7294),r=t(6742),s=t(5977),o=t(6010),i=t(9443);var l=function(){var e=(0,a.useContext)(i.Z);if(null==e)throw new Error('"useUserPreferencesContext" is used outside of "Layout" component.');return e},u={assemblyscript:"AssemblyScript",c:"C / C++",c3:"C3",d:"D",go:"Go",grain:"Grain",nelua:"Nelua",nim:"Nim",odin:"Odin",penne:"Penne",porth:"Porth",roland:"Roland",rust:"Rust",wat:"WebAssembly Text",zig:"Zig"};function p(e){return"string"==typeof e&&Object.prototype.hasOwnProperty.call(u,e)}function d(e){return(null!=e?e:"").trim().toLowerCase()}function c(e){var n=e.children,t=e.hidden,r=e.className;return a.createElement("div",{hidden:t,className:r},n)}function A(e){var n=a.Children.toArray(e.children),t=n.map((function(e){return e.props.value})),i=function(){var e=l(),n=e.tabGroupChoices,t=e.setTabGroupChoices,r=(0,a.useState)("assemblyscript"),s=r[0],o=r[1],i=function(e){var n=p(e);n?(o(e),t("language",e)):n||console.warn('MultilanguageCode: invalid code-lang received: "'+e+'"')},u=(0,a.useRef)(i);(0,a.useEffect)((function(){u.current=i}));var c="undefined"!=typeof window?window.location.search:"",A=n.language;return(0,a.useLayoutEffect)((function(){var e=d(A);p(e)&&o(e)}),[A]),(0,a.useEffect)((function(){var e=d(new URLSearchParams(c).get("code-lang"));p(e)&&u.current(e)}),[c]),{activeLang:s,updateLang:i}}().activeLang,c=(0,s.k6)(),A=t.includes(i)?i:t.includes("assemblyscript")?"assemblyscript":t[0],m=a.createElement("div",{className:"dropdown dropdown--hoverable dropdown--right"},a.createElement("a",{className:"navbar__link"},u[A]," "),a.createElement("ul",{className:"dropdown__menu text--left"},Object.entries(u).filter((function(e){return t.includes(e[0])})).map((function(e){var n=e[0],t=e[1],s=c.location.pathname+"?code-lang="+n+(c.location.hash||"#no-scroll");return a.createElement("li",{key:n},a.createElement(r.Z,{to:s,replace:!0,className:(0,o.Z)("dropdown__link",n===A&&"dropdown__link--active")},t))}))));return a.createElement("div",null,a.createElement("div",{className:"multilang"},m),a.createElement("div",null,n.map((function(e){return(0,a.cloneElement)(e,{key:e.props.value,hidden:e.props.value!==A})}))))}},8761:function(e,n,t){"use strict";t.r(n),t.d(n,{frontMatter:function(){return l},contentTitle:function(){return u},metadata:function(){return p},toc:function(){return d},default:function(){return A}});var a=t(2122),r=t(9756),s=(t(7294),t(3905)),o=t(2375),i=["components"],l={},u="User Input",p={unversionedId:"tutorials/snake/handling-user-input",id:"tutorials/snake/handling-user-input",isDocsHomePage:!1,title:"User Input",description:'With a moving snake, you\'ve done a good part of the game. This part lets you give the control into the players hands. WASM-4 supports both gamepad and mouse input, but for this tutorial we will only use gamepad input. If the player presses a certain button, you just have to change the values of the "Direction"-Property of your snake.',source:"@site/docs/tutorials/snake/handling-user-input.md",sourceDirName:"tutorials/snake",slug:"/tutorials/snake/handling-user-input",permalink:"/wasm4/docs/tutorials/snake/handling-user-input",editUrl:"https://github.com/aduros/wasm4/edit/main/site/docs/tutorials/snake/handling-user-input.md",version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Moving the Snake",permalink:"/wasm4/docs/tutorials/snake/moving-the-snake"},next:{title:"Placing the Fruit",permalink:"/wasm4/docs/tutorials/snake/placing-the-fruit"}},d=[{value:"Gamepad Basics",id:"gamepad-basics",children:[]},{value:"Keyboard Layout",id:"keyboard-layout",children:[]},{value:"Detecting <code>justPressed</code>",id:"detecting-justpressed",children:[]},{value:"Changing Directions",id:"changing-directions",children:[]}],c={toc:d};function A(e){var n=e.components,l=(0,r.Z)(e,i);return(0,s.kt)("wrapper",(0,a.Z)({},c,l,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"user-input"},"User Input"),(0,s.kt)("p",null,"With a moving snake, you've done a good part of the game. This part lets you give the control into the players hands. WASM-4 supports both ",(0,s.kt)("a",{parentName:"p",href:"/docs/guides/user-input#gamepad"},"gamepad")," and ",(0,s.kt)("a",{parentName:"p",href:"/docs/guides/user-input#mouse"},"mouse input"),', but for this tutorial we will only use gamepad input. If the player presses a certain button, you just have to change the values of the "Direction"-Property of your snake.'),(0,s.kt)("p",null,"That's it."),(0,s.kt)("p",null,"But first, you need to understand how WASM-4 handles user input."),(0,s.kt)("h2",{id:"gamepad-basics"},"Gamepad Basics"),(0,s.kt)("p",null,"WASM-4 accepts up to 4 gamepads and provides 4 variables that represent the current state of this gamepads. It contains a value ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," (zero) if nothing has been pressed; otherwise, it contains a sum of the buttons pressed, based on the table below:"),(0,s.kt)("table",null,(0,s.kt)("thead",{parentName:"table"},(0,s.kt)("tr",{parentName:"thead"},(0,s.kt)("th",{parentName:"tr",align:null},"Button"),(0,s.kt)("th",{parentName:"tr",align:"center"},"Value"))),(0,s.kt)("tbody",{parentName:"table"},(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"Button 1"),(0,s.kt)("td",{parentName:"tr",align:"center"},"1")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"Button 2"),(0,s.kt)("td",{parentName:"tr",align:"center"},"2")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"Left"),(0,s.kt)("td",{parentName:"tr",align:"center"},"16")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"Right"),(0,s.kt)("td",{parentName:"tr",align:"center"},"32")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"Up"),(0,s.kt)("td",{parentName:"tr",align:"center"},"64")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"Down"),(0,s.kt)("td",{parentName:"tr",align:"center"},"128")))),(0,s.kt)("p",null,'So if the player presses "Right" and "Button 1", the value would be 33. Now are all values "a power of two", meaning you can set and check them using binary operators.'),(0,s.kt)("p",null,"If you want to check if Button 1 is pressed, simply use the binary AND:"),(0,s.kt)("p",null,"This is true for all other buttons too."),(0,s.kt)("h2",{id:"keyboard-layout"},"Keyboard Layout"),(0,s.kt)("p",null,"For the player side of things, WASM-4 tries to cover most keyboard layouts:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"X and Space = Button 1"),(0,s.kt)("li",{parentName:"ul"},"Y, C and Z = Button 2")),(0,s.kt)("p",null,"This should cover QWERTY, QWERTZ and Dvorak layouts."),(0,s.kt)("p",null,"The gamepads for the players 2, 3 and 4 are currently not implemented."),(0,s.kt)("h2",{id:"detecting-justpressed"},"Detecting ",(0,s.kt)("inlineCode",{parentName:"h2"},"justPressed")),(0,s.kt)("p",null,"Since the current state of the gamepad is stored in a single variable, you need to compare it to the previous state."),(0,s.kt)("p",null,"You can achieve this by using the bitwise XOR operator. To make it short, here is the code snippet you can use:"),(0,s.kt)(o.Z,{mdxType:"MultiLanguage"},(0,s.kt)(o.T,{value:"assemblyscript",mdxType:"Page"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},"const gamepad = load<u8>(w4.GAMEPAD1);\nconst justPressed = gamepad & (gamepad ^ prevState)\n")),(0,s.kt)("p",null,"The constant ",(0,s.kt)("inlineCode",{parentName:"p"},"justPressed")," now holds all buttons that were pressed this frame. You can check the state of a single button like this:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-go"},"if (justPressed & w4.BUTTON_UP) {\n    // Do something\n}\n"))),(0,s.kt)(o.T,{value:"c",mdxType:"Page"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},"const uint8_t just_pressed = *GAMEPAD1 & (*GAMEPAD1 ^ prev_state);\n")),(0,s.kt)("p",null,"The variable ",(0,s.kt)("inlineCode",{parentName:"p"},"just_pressed")," now holds all buttons that were pressed this frame, ",(0,s.kt)("inlineCode",{parentName:"p"},"prev_state")," which we will define in a moment, holds the gamepad state from the previous frame. You can check the state of a single button like this:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},"if (just_pressed & BUTTON_UP)\n{\n    //move snake up\n} \n"))),(0,s.kt)(o.T,{value:"d",mdxType:"Page"},(0,s.kt)("p",null,"// TODO")),(0,s.kt)(o.T,{value:"go",mdxType:"Page"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-go"},"justPressed := *w4.GAMEPAD1 & (*w4.GAMEPAD1 ^ prevState)\n")),(0,s.kt)("p",null,"The variable ",(0,s.kt)("inlineCode",{parentName:"p"},"justPressed")," now holds all buttons that were pressed this frame. You can check the state of a single button like this:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-go"},"if justPressed&w4.BUTTON_UP != 0 {\n    // Do something\n}\n"))),(0,s.kt)(o.T,{value:"nelua",mdxType:"Page"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-lua"},"local gamepad = $GAMEPAD1\nlocal just_pressed = gamepad & (gamepad ~ prev_state)\n")),(0,s.kt)("p",null,"The constant ",(0,s.kt)("inlineCode",{parentName:"p"},"just_pressed")," now holds all buttons that were pressed this frame. You can check the state of a single button like this:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-lua"},"if just_pressed & BUTTON_UP ~= 0 then\n  -- Do something\nend\n"))),(0,s.kt)(o.T,{value:"nim",mdxType:"Page"},(0,s.kt)("p",null,"// TODO")),(0,s.kt)(o.T,{value:"odin",mdxType:"Page"},(0,s.kt)("p",null,"// TODO")),(0,s.kt)(o.T,{value:"porth",mdxType:"Page"},(0,s.kt)("p",null,"// TODO")),(0,s.kt)(o.T,{value:"rust",mdxType:"Page"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},"let gamepad = unsafe { *wasm4::GAMEPAD1 };\nlet just_pressed = gamepad & (gamepad ^ prev_gamepad);\n")),(0,s.kt)("p",null,"The constant ",(0,s.kt)("inlineCode",{parentName:"p"},"just_pressed")," now holds all buttons that were pressed this frame. You can check the state of a single button like this:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},"if just_pressed & wasm4::BUTTON_UP != 0 {\n  // Do something\n}\n"))),(0,s.kt)(o.T,{value:"wat",mdxType:"Page"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-wasm"},"(local $gamepad i32)\n(local $just-pressed i32)\n\n;; gamepad = *GAMEPAD;\n(local.set $gamepad (i32.load8_u (global.get $GAMEPAD1)))\n\n;; just-pressed = gamepad & (gamepad ^ prev-state);\n(local.set $just-pressed\n  (i32.and\n    (local.get $gamepad)\n    (i32.xor\n      (local.get $gamepad)\n      (global.get $prev-state))))\n\n")),(0,s.kt)("p",null,"The local variable ",(0,s.kt)("inlineCode",{parentName:"p"},"just-pressed")," now holds all buttons that were pressed this frame. You can check the state of a single button like this:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-wasm"},"(if (i32.and (local.get $just-pressed) (global.get $BUTTON_UP))\n  (then\n    ;; Do something\n  )\n)\n"))),(0,s.kt)(o.T,{value:"zig",mdxType:"Page"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-zig"},"const gamepad = w4.GAMEPAD1.*;\nconst just_pressed = gamepad & (gamepad ^ prev_state);\n")),(0,s.kt)("p",null,"The constant ",(0,s.kt)("inlineCode",{parentName:"p"},"just_pressed")," now holds all buttons that were pressed this frame. You can check the state of a single button like this:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-zig"},"if (just_pressed & w4.BUTTON_UP != 0) {\n    // Do something\n}\n")))),(0,s.kt)("p",null,"If you don't care ",(0,s.kt)("em",{parentName:"p"},"why")," that is, ",(0,s.kt)("a",{parentName:"p",href:"#changing-directions"},"skip to the next part"),"."),(0,s.kt)("p",null,'Like I explained in "Gamepad Basics", the value of Gamepad 1 is a combination of all currently pressed buttons. If we store it and use XOR or later on, we only get the differences.'),(0,s.kt)("p",null,"Let's assume the right button is currently pressed. In that case Gamepad 1 has the value 32 (Right = 32). Now the player presses Button 1. The value changes from 32 to 33 (Button 1 + Right = 1 + 32 = 33). By using XOR, we get 1 as a result."),(0,s.kt)("p",null,"In the next step, we compare it to the current state. Like: What buttons are ",(0,s.kt)("em",{parentName:"p"},"new")," this frame."),(0,s.kt)("p",null,'Here\'s a "hands-on" example:'),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},'Frame 0: Gamepad1 = 0 (No buttons are pressed)\nFrame 1: Gamepad1 = 32 (Right button is pressed)\n\nDifference between Frame 0 and 1:\n  00000000 (0)\n^ 00100000 (32)\n= 00100000 (32)\n\nWhat\'s new:\n  00100000 (32)\n& 00100000 (32)\n= 00100000 (32)\n\nResult: "32" is new\n\n----\n\nFrame 2: Gamepad1 = 33 (Right button and Button 1 are pressed)\n\nDifferences between Frame 1 and 2:\n  00100000 (32)\n^ 00100001 (33)\n= 00000001 (1)\n\nWhat\'s new:\n  00000001 (1)\n& 00100001 (33)\n= 00000001 (1)\n\nResult: "1" is new\n\n----\n\nFrame 3: Gamepad1 = 1 (Button 1 is pressed, Right button got released)\n\nDifference between Frame 2 and 3:\n  00100001 (33)\n^ 00000001 (1)\n= 00100000 (32)\n\nWhat\'s new:\n  00100000 (32)\n& 00000001 (1)\n= 00000000 (0)\n\nResult: No new key was pressed this frame.\n\n')),(0,s.kt)("h2",{id:"changing-directions"},"Changing Directions"),(0,s.kt)("p",null,"Now that you know how to detect if a key was pressed in the current frame, it's time you let the player change the direction of the snake."),(0,s.kt)("p",null,"Like most of this tutorial, this is step is rather easy once you've grasped how it works."),(0,s.kt)("p",null,"For this, you need to change the update function of in the main file. Remember, this is how it currently looks like:"),(0,s.kt)(o.Z,{mdxType:"MultiLanguage"},(0,s.kt)(o.T,{value:"assemblyscript",mdxType:"Page"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},"export function update(): void {\n    frameCount++\n\n    if (frameCount % 15 == 0) {\n        snake.update()\n    }\n\n    snake.draw()\n}\n"))),(0,s.kt)(o.T,{value:"c",mdxType:"Page"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},"void update () \n{\n    frame_count++;\n    if(frame_count % 15 == 0)\n    {\n      snake_update(&snake);\n    }\n    snake_draw(&snake);\n}\n"))),(0,s.kt)(o.T,{value:"d",mdxType:"Page"},(0,s.kt)("p",null,"// TODO")),(0,s.kt)(o.T,{value:"go",mdxType:"Page"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-go"},"//go:export update\nfunc update() {\n    frameCount++\n\n    if frameCount%15 == 0 {\n        snake.Update()\n    }\n\n    snake.Draw()\n}\n"))),(0,s.kt)(o.T,{value:"nelua",mdxType:"Page"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-lua"},"local function update()\n  frame_count = frame_count + 1\n\n  if frame_count % 15 == 0 then\n    snake:update()\n  end\n\n  snake:draw()\nend\n"))),(0,s.kt)(o.T,{value:"nim",mdxType:"Page"},(0,s.kt)("p",null,"// TODO")),(0,s.kt)(o.T,{value:"odin",mdxType:"Page"},(0,s.kt)("p",null,"// TODO")),(0,s.kt)(o.T,{value:"porth",mdxType:"Page"},(0,s.kt)("p",null,"// TODO")),(0,s.kt)(o.T,{value:"rust",mdxType:"Page"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},"// src/game.rs\nuse crate::snake::{Point, Snake};\nuse crate::wasm4;\n\npub struct Game {\n    snake: Snake,\n    frame_count: u32,\n}\n\nimpl Game {\n    pub fn new() -> Self {\n        Self {\n            snake: Snake::new(),\n            frame_count: 0,\n        }\n    }\n\n    pub fn update(&mut self) {\n        self.frame_count += 1;\n\n        if self.frame_count % 15 == 0 {\n            self.snake.update();\n        }\n        self.snake.draw();\n    }\n}\n"))),(0,s.kt)(o.T,{value:"wat",mdxType:"Page"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-wasm"},'(func (export "update")\n  ;; frame-count = frame-count + 1;\n  (global.set $frame-count (i32.add (global.get $frame-count) (i32.const 1)))\n\n  ;; if ((frame-count % 15) == 0) ...\n  (if (i32.eqz (i32.rem_u (global.get $frame-count) (i32.const 15)))\n    (then\n      (call $snake-update)))\n\n  (call $snake-draw)\n)\n'))),(0,s.kt)(o.T,{value:"zig",mdxType:"Page"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-zig"},"export fn update() void {\n    frame_count += 1;\n\n    if (frame_count % 15 == 0) {\n        snake.update()\n    }\n\n    snake.draw()\n}\n")))),(0,s.kt)("p",null,"The classic processing loop goes like this: Input, Process the input, output the result. Or in case of most games: User-Input, Update, Render. The last two steps are already in place. Now it's time to add the first part."),(0,s.kt)(o.Z,{mdxType:"MultiLanguage"},(0,s.kt)(o.T,{value:"assemblyscript",mdxType:"Page"},(0,s.kt)("p",null,"It's a good idea to handle the input in its own function. Something like this could be on your mind:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"{1-8,13}","{1-8,13}":!0},"function input(): void {\n    const gamepad = load<u8>(w4.GAMEPAD1);\n    const justPressed = gamepad & (gamepad ^ prevState)\n\n    if (justPressed & w4.BUTTON_UP) {\n        // Do something\n    }\n}\n\nexport function update(): void {\n    frameCount++\n\n    input()\n\n    if (frameCount % 15 == 0) {\n        snake.update()\n    }\n\n    snake.draw()\n}\n")),(0,s.kt)("p",null,"If you try to compile this, you should get an error: ",(0,s.kt)("inlineCode",{parentName:"p"},"ERROR TS2304: Cannot find name 'prevState'."),". This is easily fixed. Just place the prevState into the var-section:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"{2}","{2}":!0},"const snake = new Snake()\nlet prevState: u8\nlet frameCount = 0\n")),(0,s.kt)("p",null,"To notice any change in the gamepad, you have to store the ",(0,s.kt)("em",{parentName:"p"},"current state")," at the end of the input. This will make it the ",(0,s.kt)("em",{parentName:"p"},"previous state"),". And while you're at it, why not add the other 3 directions along the way:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"{8-18}","{8-18}":!0},"function input(): void {\n    const gamepad = load<u8>(w4.GAMEPAD1);\n    const justPressed = gamepad & (gamepad ^ prevState)\n\n    if (justPressed & w4.BUTTON_LEFT) {\n        // Do something\n    }\n    if (justPressed & w4.BUTTON_RIGHT) {\n        // Do something\n    }\n    if (justPressed & w4.BUTTON_UP) {\n        // Do something\n    }\n    if (justPressed & w4.BUTTON_DOWN) {\n        // Do something\n    }\n\n    prevState = gamepad\n}\n")),(0,s.kt)("p",null,"If you want to check if it works: Use the ",(0,s.kt)("inlineCode",{parentName:"p"},"trace")," function provided by WASM-4. Here's an example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},'    if (justPressed & w4.BUTTON_DOWN) {\n        w4.trace("down")\n    }\n')),(0,s.kt)("p",null,"If you use ",(0,s.kt)("inlineCode",{parentName:"p"},"trace")," in each if-statement, you should see the corresponding output in the console."),(0,s.kt)("p",null,"Now, instead of using ",(0,s.kt)("inlineCode",{parentName:"p"},"trace")," to confirm everything works as intended, you should replace it with something like this:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},"    if (justPressed & w4.BUTTON_DOWN) {\n        snake.down()\n    }\n")),(0,s.kt)("p",null,"I'll leave it to you, to finish the other 3 directions."),(0,s.kt)("p",null,"You'll be - once again - rewarded with error messages:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"ERROR TS2339: Property 'up' does not exist on type 'src/snake/Snake'.\nERROR TS2339: Property 'down' does not exist on type 'src/snake/Snake'.\nERROR TS2339: Property 'left' does not exist on type 'src/snake/Snake'.\nERROR TS2339: Property 'right' does not exist on type 'src/snake/Snake'.\n")),(0,s.kt)("p",null,"To fix this, add those functions to your snake. Here's an example for ",(0,s.kt)("inlineCode",{parentName:"p"},"down"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},"    down(): void {\n        if (this.direction.y == 0) {\n            this.direction.x = 0\n            this.direction.y = 1\n        }\n    }\n"))),(0,s.kt)(o.T,{value:"c",mdxType:"Page"},(0,s.kt)("p",null,"It's a good idea to handle the input in its own function. Something like this could be on your mind:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c",metastring:"{1-9,15}","{1-9,15}":!0},"void input()\n{\n  const uint8_t just_pressed = *GAMEPAD1 & (*GAMEPAD1 ^ prev_state);\n\n  if (just_pressed & BUTTON_UP)\n  {\n    //move snake up\n  } \n}\n\nvoid update () \n{\n  frame_count++;\n\n  input();\n\n  if(frame_count % 15 == 0)\n  {\n    snake_update(&snake);\n  }\n  snake_draw(&snake);\n}\n")),(0,s.kt)("p",null,"If you try to compile this, you should get an error as ",(0,s.kt)("inlineCode",{parentName:"p"},"prev_state")," is not yet declared. Place ",(0,s.kt)("inlineCode",{parentName:"p"},"prev_state")," at the top of ",(0,s.kt)("inlineCode",{parentName:"p"},"main.c"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c",metastring:"{7}","{7}":!0},'#include "wasm4.h"\n#include "snake.h"\n#include <stdlib.h>\n\nstruct snake snake;\nint frame_count = 0;\nuint8_t prev_state = 0;\n')),(0,s.kt)("p",null,"To notice any change in the gamepad, you have to store the ",(0,s.kt)("em",{parentName:"p"},"current state")," at the end of the input. This will make it the ",(0,s.kt)("em",{parentName:"p"},"previous state"),". And while you're at it, why not add the other 3 directions along the way:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c",metastring:"{9-23}","{9-23}":!0},"void input()\n{\n    const uint8_t just_pressed = *GAMEPAD1 & (*GAMEPAD1 ^ prev_state);\n\n    if (just_pressed & BUTTON_UP)\n    {\n        //move snake up\n    } \n    if(just_pressed & BUTTON_DOWN)\n    {\n        //move snake down\n    }\n    if(just_pressed & BUTTON_LEFT)\n    {\n        //move snake left\n    }\n    if(just_pressed & BUTTON_RIGHT)\n    {\n        //move snake right\n    }\n \n    prev_state = *GAMEPAD1;\n}\n")),(0,s.kt)("p",null,"If you want to check if it works: Use the ",(0,s.kt)("inlineCode",{parentName:"p"},"trace")," function provided by WASM-4. Here's an example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},'    if (just_pressed & BUTTON_UP)\n    {\n        trace("Button up");\n    } \n')),(0,s.kt)("p",null,"If you use ",(0,s.kt)("inlineCode",{parentName:"p"},"trace")," in each if-statement, you should see the corresponding output in the console."),(0,s.kt)("p",null,"Now, instead of using ",(0,s.kt)("inlineCode",{parentName:"p"},"trace")," to confirm everything works as intended, you should replace it with something like this:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},"    if (just_pressed & BUTTON_UP)\n    {\n        snake_up(&snake);\n    } \n")),(0,s.kt)("p",null,"Fill in equivalent code for the remaining three directions and then add the function declarations to the ",(0,s.kt)("inlineCode",{parentName:"p"},"snake.h")," file:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},"void snake_up(struct snake *snake);\nvoid snake_down(struct snake *snake);\nvoid snake_left(struct snake *snake);\nvoid snake_right(struct snake *snake);\n")),(0,s.kt)("p",null,"Now add the bodies of these functions to ",(0,s.kt)("inlineCode",{parentName:"p"},"snake.c"),". Here's an example for ",(0,s.kt)("inlineCode",{parentName:"p"},"snake_down"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},"void snake_down(struct snake *snake)\n{\n    if(snake->direction.y == 0)\n    { \n        snake->direction = (struct point){0,1};\n    }\n}\n"))),(0,s.kt)(o.T,{value:"d",mdxType:"Page"},(0,s.kt)("p",null,"// TODO")),(0,s.kt)(o.T,{value:"go",mdxType:"Page"},(0,s.kt)("p",null,"It's a good idea to handle the input in its own function. Something like this could be on your mind:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-go",metastring:"{1-7,13}","{1-7,13}":!0},"func input() {\n    justPressed := *w4.GAMEPAD1 & (*w4.GAMEPAD1 ^ prevState)\n\n    if justPressed&w4.BUTTON_UP != 0 {\n        // Do something\n    }\n}\n\n//go:export update\nfunc update() {\n    frameCount++\n\n    input()\n\n    if frameCount%15 == 0 {\n        snake.Update()\n    }\n\n    snake.Draw()\n}\n")),(0,s.kt)("p",null,"If you try to compile this, you should get an error: ",(0,s.kt)("inlineCode",{parentName:"p"},"undeclared name: prevState"),". This is easily fixed. Just place the prevState into the var-section:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-go",metastring:"{11}","{11}":!0},"var (\n    snake = &Snake{\n        Body: []Point{\n            {X: 2, Y: 0},\n            {X: 1, Y: 0},\n            {X: 0, Y: 0},\n        },\n        Direction: Point{X: 1, Y: 0},\n    }\n    frameCount = 0\n    prevState  uint8\n)\n")),(0,s.kt)("p",null,"To notice any change in the gamepad, you have to store the ",(0,s.kt)("em",{parentName:"p"},"current state")," at the end of the input. This will make it the ",(0,s.kt)("em",{parentName:"p"},"previous state"),". And while you're at it, why not add the other 3 directions along the way:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-go",metastring:"{7-17}","{7-17}":!0},"func input() {\n    justPressed := *w4.GAMEPAD1 & (*w4.GAMEPAD1 ^ prevState)\n\n    if justPressed&w4.BUTTON_UP != 0 {\n        // Do something\n    }\n    if justPressed&w4.BUTTON_DOWN != 0 {\n        // Do something\n    }\n    if justPressed&w4.BUTTON_LEFT != 0 {\n        // Do something\n    }\n    if justPressed&w4.BUTTON_RIGHT != 0 {\n        // Do something\n    }\n\n    prevState = *w4.GAMEPAD1\n}\n")),(0,s.kt)("p",null,"If you want to check if it works: Use the ",(0,s.kt)("inlineCode",{parentName:"p"},"Trace")," function provided by WASM-4. Here's an example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-go"},'    if justPressed&w4.BUTTON_DOWN != 0 {\n        w4.Trace("Down")\n    }\n')),(0,s.kt)("p",null,"If you use ",(0,s.kt)("inlineCode",{parentName:"p"},"Trace")," in each if-statement, you should see the corresponding output in the console."),(0,s.kt)("p",null,"Now, instead of using ",(0,s.kt)("inlineCode",{parentName:"p"},"Trace")," to confirm everything works as intended, you should replace it with something like this:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-go"},"    if justPressed&w4.BUTTON_DOWN != 0 {\n        snake.Down()\n    }\n")),(0,s.kt)("p",null,"I'll leave it to you, to finish the other 3 directions."),(0,s.kt)("p",null,"You'll be - once again - rewarded with error messages:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"snake.Up undefined (type *Snake has no field or method Up)\nsnake.Down undefined (type *Snake has no field or method Down)\nsnake.Left undefined (type *Snake has no field or method Left)\nsnake.Right undefined (type *Snake has no field or method Right)\n")),(0,s.kt)("p",null,"To fix this, add those functions to your snake. Here's an example for ",(0,s.kt)("inlineCode",{parentName:"p"},"Down"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-go"},"func (s *Snake) Down() {\n    if s.Direction.Y == 0 {\n        s.Direction = Point{X: 0, Y: 1}\n    }\n}\n"))),(0,s.kt)(o.T,{value:"nelua",mdxType:"Page"},(0,s.kt)("p",null,"It's a good idea to handle the input in its own function. Something like this could be on your mind:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-lua",metastring:"{1-8,13}","{1-8,13}":!0},"local function input()\n  local gamepad = $GAMEPAD1\n  local just_pressed = gamepad & (gamepad ~ prev_state)\n\n  if just_pressed & BUTTON_UP ~= 0 then\n    -- Do something\n  end\nend\n\nlocal function update()\n  frame_count = frame_count + 1\n\n  input()\n\n  if frame_count % 15 == 0 then\n    snake:update()\n  end\n\n  snake:draw()\nend\n")),(0,s.kt)("p",null,"If you try to compile this, you should get an error: ",(0,s.kt)("inlineCode",{parentName:"p"},"error: undeclared symbol 'prev_state'"),". This is easily fixed. Just place the prev_state into the var-section:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-lua",metastring:"{3}","{3}":!0},"local snake = Snake.init()\nlocal frame_count = 0\nlocal prev_state = 0\n")),(0,s.kt)("p",null,"To notice any change in the gamepad, you have to store the ",(0,s.kt)("em",{parentName:"p"},"current state")," at the end of the input. This will make it the ",(0,s.kt)("em",{parentName:"p"},"previous state"),". And while you're at it, why not add the other 3 directions along the way:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-lua",metastring:"{5-18}","{5-18}":!0},"local function input()\n  local gamepad = $GAMEPAD1\n  local just_pressed = gamepad & (gamepad ~ prev_state)\n\n  if just_pressed & BUTTON_LEFT ~= 0 then\n    -- Do something\n  end\n  if just_pressed & BUTTON_RIGHT ~= 0 then\n    -- Do something\n  end\n  if just_pressed & BUTTON_UP ~= 0 then\n    -- Do something\n  end\n  if just_pressed & BUTTON_DOWN ~= 0 then\n    -- Do something\n  end\n\n  prev_state = gamepad\nend\n")),(0,s.kt)("p",null,"If you want to check if it works: Use the ",(0,s.kt)("inlineCode",{parentName:"p"},"trace")," function provided by WASM-4. Here's an example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-lua"},'if just_pressed & BUTTON_DOWN ~= 0 then\n  trace("down")\nend\n')),(0,s.kt)("p",null,"If you use ",(0,s.kt)("inlineCode",{parentName:"p"},"trace")," in each if-statement, you should see the corresponding output in the console."),(0,s.kt)("p",null,"Now, instead of using ",(0,s.kt)("inlineCode",{parentName:"p"},"trace")," to confirm everything works as intended, you should replace it with something like this:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-lua"},"if just_pressed & BUTTON_DOWN ~= 0 then\n  snake:down()\nend\n")),(0,s.kt)("p",null,"I'll leave it to you, to finish the other 3 directions."),(0,s.kt)("p",null,"You'll be - once again - rewarded with an error message:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"src/main.nelua:1:1: from: AST node Block\nrequire \"wasm4\"\n^~~~~~~~~~~~~~~\nsrc/main.nelua:19:3: from: AST node Block\n  local gamepad = $GAMEPAD1\n  ^~~~~~~~~~~~~~~~~~~~~~~~~\nsrc/main.nelua:23:5: from: AST node Block\n    snake:left()\n    ^~~~~~~~~~~~\nsrc/main.nelua:23:10: error: cannot index meta field 'left' for type 'snake.Snake'\n    snake:left()\n         ^~~~~~~\n")),(0,s.kt)("p",null,"Nelua will only list this first unknown it finds, but you'll get an error for each function as you add them. To fix the errors, add those functions to your snake. Here's an example for ",(0,s.kt)("inlineCode",{parentName:"p"},"down"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-lua"},"function Snake:down()\n  if self.direction.y == 0 then\n    self.direction = {x = 0, y = 1}\n  end\nend\n"))),(0,s.kt)(o.T,{value:"nim",mdxType:"Page"},(0,s.kt)("p",null,"// TODO")),(0,s.kt)(o.T,{value:"odin",mdxType:"Page"},(0,s.kt)("p",null,"// TODO")),(0,s.kt)(o.T,{value:"porth",mdxType:"Page"},(0,s.kt)("p",null,"// TODO")),(0,s.kt)(o.T,{value:"rust",mdxType:"Page"},(0,s.kt)("p",null,"It's a good idea to handle the input in its own function. Something like this could be on your mind:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust",metastring:"{21,29-36}","{21,29-36}":!0},"// src/game.rs\nuse crate::snake::{Point, Snake};\nuse crate::wasm4;\n\npub struct Game {\n    snake: Snake,\n    frame_count: u32,\n}\n\nimpl Game {\n    pub fn new() -> Self {\n        Self {\n            snake: Snake::new(),\n            frame_count: 0,\n        }\n    }\n\n    pub fn update(&mut self) {\n        self.frame_count += 1;\n\n        self.input();\n\n        if self.frame_count % 15 == 0 {\n            self.snake.update();\n        }\n        self.snake.draw();\n    }\n\n    pub fn input(&mut self) {\n        let gamepad = unsafe { *wasm4::GAMEPAD1 };\n        let just_pressed = gamepad & (gamepad ^ prev_gamepad);\n\n        if just_pressed & wasm4::BUTTON_UP != 0 {\n          // Do something\n        }\n    }\n}\n")),(0,s.kt)("p",null,"If you try to compile this, you should get an error: ",(0,s.kt)("inlineCode",{parentName:"p"},"cannot find value prev_gamepad in this scope"),".\nJust place ",(0,s.kt)("inlineCode",{parentName:"p"},"prev_gamepad")," in ",(0,s.kt)("inlineCode",{parentName:"p"},"Game"),"."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust",metastring:"{8,16}","{8,16}":!0},"// src/game.rs\nuse crate::snake::{Point, Snake};\nuse crate::wasm4;\n\npub struct Game {\n    snake: Snake,\n    frame_count: u32,\n    prev_gamepad: u8,\n}\n\nimpl Game {\n    pub fn new() -> Self {\n        Self {\n            snake: Snake::new(),\n            frame_count: 0,\n            prev_gamepad: 0,\n        }\n    }\n}\n")),(0,s.kt)("p",null,"To notice any change in the gamepad, you have to store the ",(0,s.kt)("em",{parentName:"p"},"current state")," at the end of the input. This will make it the ",(0,s.kt)("em",{parentName:"p"},"previous state"),". And while you're at it, why not add the other 3 directions along the way:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},"// src/game.rs\nuse crate::snake::{Point, Snake};\nuse crate::wasm4;\n\npub struct Game {\n    snake: Snake,\n    frame_count: u32,\n}\n\nimpl Game {\n    pub fn new() -> Self {\n        Self {\n            snake: Snake::new(),\n            frame_count: 0,\n        }\n    }\n\n    pub fn update(&mut self) {\n        self.frame_count += 1;\n\n        self.input();\n\n        if self.frame_count % 15 == 0 {\n            self.snake.update();\n        }\n        self.snake.draw();\n    }\n\n    pub fn input(&mut self) {\n        let gamepad = unsafe { *wasm4::GAMEPAD1 };\n        let just_pressed = gamepad & (gamepad ^ self.prev_gamepad);\n\n        if just_pressed & wasm4::BUTTON_LEFT != 0 {\n            // Do something\n        }\n        if just_pressed & wasm4::BUTTON_RIGHT != 0 {\n            // Do something\n        }\n        if just_pressed & wasm4::BUTTON_UP != 0 {\n            // Do something\n        }\n        if just_pressed & wasm4::BUTTON_DOWN != 0 {\n            // Do something\n        }\n\n        self.prev_gamepad = gamepad;\n    }\n}\n")),(0,s.kt)("p",null,"If you want to check if it works: Use the ",(0,s.kt)("inlineCode",{parentName:"p"},"trace")," function provided by WASM-4. Here's an example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},'// src/game.rs\nif just_pressed & wasm4::BUTTON_DOWN != 0 {\n    wasm4::trace("down");\n}\n')),(0,s.kt)("p",null,"If you use ",(0,s.kt)("inlineCode",{parentName:"p"},"trace")," in each if-statement, you should see the corresponding output in the console."),(0,s.kt)("p",null,"Now, instead of using ",(0,s.kt)("inlineCode",{parentName:"p"},"trace")," to confirm everything works as intended, you should replace it with something like this:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},"// src/game.rs\nif just_pressed & wasm4::BUTTON_DOWN != 0 {\n   self.snake.down();\n}\n")),(0,s.kt)("p",null,"I'll leave it to you, to finish the other 3 directions."),(0,s.kt)("p",null,"You'll be - once again - rewarded with an error message:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"no method named `down` found for struct `Snake` in the current scope\nmethod not found in `Snake`\n")),(0,s.kt)("p",null,"To fix the errors, add those functions to your snake. Here's an example for ",(0,s.kt)("inlineCode",{parentName:"p"},"down"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},"// src/snake.rs\n    pub fn down(&mut self) {\n        if self.direction.y == 0 {\n            self.direction = Point { x: 0, y: 1 };\n        }\n    }\n"))),(0,s.kt)(o.T,{value:"wat",mdxType:"Page"},(0,s.kt)("p",null,"It's a good idea to handle the input in its own function. Something like this could be on your mind:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-wasm"},'(func $input\n  (local $gamepad i32)\n  (local $just-pressed i32)\n\n  ;; gamepad = *GAMEPAD;\n  (local.set $gamepad (i32.load8_u (global.get $GAMEPAD1)))\n\n  ;; just-pressed = gamepad & (gamepad ^ prev-state);\n  (local.set $just-pressed\n    (i32.and\n      (local.get $gamepad)\n      (i32.xor\n        (local.get $gamepad)\n        (global.get $prev-state))))\n\n  (if (i32.and (local.get $just-pressed) (global.get $BUTTON_LEFT))\n    (then\n      ;; Do something\n    )\n  )\n)\n\n(func (export "update")\n  ;; frame-count = frame-count + 1;\n  (global.set $frame-count (i32.add (global.get $frame-count) (i32.const 1)))\n\n  (call $input)\n\n  ;; if ((frame-count % 15) == 0) ...\n  (if (i32.eqz (i32.rem_u (global.get $frame-count) (i32.const 15)))\n    (then\n      (call $snake-update)))\n\n  (call $snake-draw)\n)\n')),(0,s.kt)("p",null,"If you try to compile this, you should get an error: ",(0,s.kt)("inlineCode",{parentName:"p"},'error: undefined local variable "$prev-state"'),". This is easily fixed. Just create a ",(0,s.kt)("inlineCode",{parentName:"p"},"$prev-state")," global variable:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-wasm"},"(global $prev-state (mut i32) (i32.const 0))\n")),(0,s.kt)("p",null,"To notice any change in the gamepad, you have to store the ",(0,s.kt)("em",{parentName:"p"},"current state")," at the end of the input. This will make it the ",(0,s.kt)("em",{parentName:"p"},"previous state"),". And while you're at it, why not add the other 3 directions along the way:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-wasm"},"(func $input\n  (local $gamepad i32)\n  (local $just-pressed i32)\n\n  ;; gamepad = *GAMEPAD;\n  (local.set $gamepad (i32.load8_u (global.get $GAMEPAD1)))\n\n  ;; just-pressed = gamepad & (gamepad ^ prev-state);\n  (local.set $just-pressed\n    (i32.and\n      (local.get $gamepad)\n      (i32.xor\n        (local.get $gamepad)\n        (global.get $prev-state))))\n\n  (if (i32.and (local.get $just-pressed) (global.get $BUTTON_LEFT))\n    (then\n      ;; Do something\n    )\n  )\n\n  (if (i32.and (local.get $just-pressed) (global.get $BUTTON_RIGHT))\n    (then\n      ;; Do something\n    )\n  )\n\n  (if (i32.and (local.get $just-pressed) (global.get $BUTTON_UP))\n    (then\n      ;; Do something\n    )\n  )\n\n  (if (i32.and (local.get $just-pressed) (global.get $BUTTON_DOWN))\n    (then\n      ;; Do something\n    )\n  )\n\n  (global.set $prev-state (local.get $gamepad))\n)\n")),(0,s.kt)("p",null,"If you want to check if it works: Use the ",(0,s.kt)("inlineCode",{parentName:"p"},"trace")," function provided by WASM-4. Here's an example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-wasm"},'  (import "env" "trace" (func $trace (param i32)))\n\n  ;; Put the string somewhere unused in memory.\n  (data (i32.const 0x3000) "down\\00")\n\n  (func $input\n    ...\n\n    ;; LEFT\n    (if (i32.and (local.get $just-pressed) (global.get $BUTTON_LEFT))\n      (then\n        (call $trace (i32.const 0x3000))\n      )\n    )\n\n    ...\n  )\n')),(0,s.kt)("p",null,"If you use ",(0,s.kt)("inlineCode",{parentName:"p"},"trace")," in each if-statement, you should see the corresponding output in the console."),(0,s.kt)("p",null,"Now, instead of using ",(0,s.kt)("inlineCode",{parentName:"p"},"trace")," to confirm everything works as intended, you should replace it with something like this:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-wasm"},"    (if (i32.and (local.get $just-pressed) (global.get $BUTTON_LEFT))\n      (then\n        (call $snake-down)))\n")),(0,s.kt)("p",null,"I'll leave it to you, to finish the other 3 directions."),(0,s.kt)("p",null,"You'll be - once again - rewarded with error messages:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},'main.wat:127:13: error: undefined function variable "$snake-left"\n      (call $snake-left)\n            ^^^^^^^^^^^\nmain.wat:134:13: error: undefined function variable "$snake-right"\n      (call $snake-right)\n            ^^^^^^^^^^^^\nmain.wat:141:13: error: undefined function variable "$snake-up"\n      (call $snake-up)\n            ^^^^^^^^^\nmain.wat:148:13: error: undefined function variable "$snake-down"\n      (call $snake-down)\n            ^^^^^^^^^^^\n')),(0,s.kt)("p",null,"To fix this, add those functions to your snake. Here's an example for ",(0,s.kt)("inlineCode",{parentName:"p"},"down"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-wasm"},"(func $snake-down\n  ;; if (direction.y == 0) {\n  ;;   direction.x = 0;\n  ;;   direction.y = 1;\n  ;; }\n  (if (i32.eq (i32.load (i32.const 0x19a4)) (i32.const 0))\n    (then\n      (i32.store (i32.const 0x19a0) (i32.const 0))\n      (i32.store (i32.const 0x19a4) (i32.const 1))))\n)\n"))),(0,s.kt)(o.T,{value:"zig",mdxType:"Page"},(0,s.kt)("p",null,"It's a good idea to handle the input in its own function. Something like this could be on your mind:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-zig",metastring:"{1-8,13}","{1-8,13}":!0},"fn input() void {\n    const gamepad = w4.GAMEPAD1.*;\n    const just_pressed = gamepad & (gamepad ^ prevState);\n\n    if (just_pressed & w4.BUTTON_UP != 0) {\n        // Do something\n    }\n}\n\nexport fn update() void {\n    frameCount += 1;\n    \n    input();\n\n    if (frame_count % 15 == 0) {\n        snake.update();\n    }\n\n    snake.draw();\n}\n")),(0,s.kt)("p",null,"If you try to compile this, you should get an error: ",(0,s.kt)("inlineCode",{parentName:"p"},"error: use of undeclared identifier 'prevState'"),". This is easily fixed. Just place the prevState into the var-section:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-zig",metastring:"{3}","{3}":!0},"var snake = Snake.init();\nvar frame_count: u32 = 0;\nvar prev_state: u8 = 0;\n")),(0,s.kt)("p",null,"To notice any change in the gamepad, you have to store the ",(0,s.kt)("em",{parentName:"p"},"current state")," at the end of the input. This will make it the ",(0,s.kt)("em",{parentName:"p"},"previous state"),". And while you're at it, why not add the other 3 directions along the way:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-zig",metastring:"{8-18}","{8-18}":!0},'fn input() void {\n    const gamepad = w4.GAMEPAD1.*;\n    const just_pressed = gamepad & (gamepad ^ prev_state)\n\n    if (just_pressed & w4.BUTTON_LEFT != 0) {\n        // Do something\n    }\n    if (just_pressed & w4.BUTTON_RIGHT != 0) {\n        // Do something\n    }\n    if (just_pressed & w4.BUTTON_UP != 0) {\n        // Do something\n    }\n    if (just_pressed & w4.BUTTON_DOWN != 0) {\n        w4.trace("down");\n    }\n\n    prev_state = gamepad;\n}\n')),(0,s.kt)("p",null,"If you want to check if it works: Use the ",(0,s.kt)("inlineCode",{parentName:"p"},"trace")," function provided by WASM-4. Here's an example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-zig"},'    if (just_pressed & w4.BUTTON_DOWN != 0) {\n        w4.trace("down");\n    }\n')),(0,s.kt)("p",null,"If you use ",(0,s.kt)("inlineCode",{parentName:"p"},"trace")," in each if-statement, you should see the corresponding output in the console."),(0,s.kt)("p",null,"Now, instead of using ",(0,s.kt)("inlineCode",{parentName:"p"},"trace")," to confirm everything works as intended, you should replace it with something like this:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-zig"},"    if (just_pressed & w4.BUTTON_DOWN != 0) {\n        snake.down();\n    }\n")),(0,s.kt)("p",null,"I'll leave it to you, to finish the other 3 directions."),(0,s.kt)("p",null,"You'll be - once again - rewarded with an error message:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"./src/main.zig:22:14: error: no member named 'left' in struct 'snake.Snake'\n        snake.left();\n             ^\ncart...The step exited with error code 1\nerror: the build command failed with exit code 1\n")),(0,s.kt)("p",null,"Zig will only list this first unknown it finds, but you'll get an error for each function as you add them. To fix the errors, add those functions to your snake. Here's an example for ",(0,s.kt)("inlineCode",{parentName:"p"},"down"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-zig"},"    pub fn down(this: *@This()) void {\n        if (this.direction.y == 0) {\n            this.direction.x = 0;\n            this.direction.y = 1;\n        }\n    }\n")))),(0,s.kt)("p",null,"First, it checks if the direction is already changing the Y-Direction. Only if it isn't allow the change. And then change the Y-Direction to 1. The ",(0,s.kt)("inlineCode",{parentName:"p"},"Up")," direction requires a Y-Direction of ",(0,s.kt)("inlineCode",{parentName:"p"},"-1"),". ",(0,s.kt)("inlineCode",{parentName:"p"},"Left")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"Right")," don't check the Y, but the X and change it accordingly (Left: -1, Right: 1)."),(0,s.kt)("p",null,"With this knowledge, you should be able to implement them. If you're unsure, check the source in the repository."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Controlled Snake",src:t(4845).Z})))}A.isMDXComponent=!0},6010:function(e,n,t){"use strict";function a(e){var n,t,r="";if("string"==typeof e||"number"==typeof e)r+=e;else if("object"==typeof e)if(Array.isArray(e))for(n=0;n<e.length;n++)e[n]&&(t=a(e[n]))&&(r&&(r+=" "),r+=t);else for(n in e)e[n]&&(r&&(r+=" "),r+=n);return r}function r(){for(var e,n,t=0,r="";t<arguments.length;)(e=arguments[t++])&&(n=a(e))&&(r&&(r+=" "),r+=n);return r}t.d(n,{Z:function(){return r}})},4845:function(e,n){"use strict";n.Z="data:image/webp;base64,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"}}]);